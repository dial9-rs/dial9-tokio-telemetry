<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Tokio Trace Viewer</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }
            body {
                font-family:
                    -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                    monospace;
                background: #1a1a2e;
                color: #e0e0e0;
                overflow: hidden;
                height: 100vh;
                display: flex;
                flex-direction: column;
            }

            #drop-zone {
                display: flex;
                align-items: center;
                justify-content: center;
                height: 100vh;
                width: 100vw;
                border: 3px dashed #444;
                border-radius: 12px;
                margin: 20px;
                font-size: 1.2em;
                color: #888;
                cursor: pointer;
                transition: all 0.2s;
            }
            #drop-zone:hover,
            #drop-zone.dragover {
                border-color: #6c63ff;
                color: #6c63ff;
                background: rgba(108, 99, 255, 0.05);
            }
            #drop-zone input {
                display: none;
            }

            #viewer {
                display: none;
                flex-direction: column;
                height: 100vh;
            }

            #toolbar {
                display: flex;
                align-items: center;
                gap: 12px;
                padding: 8px 16px;
                background: #16213e;
                border-bottom: 1px solid #333;
                flex-shrink: 0;
                min-height: 44px;
            }
            #toolbar .filename {
                font-weight: 600;
                color: #6c63ff;
            }
            #toolbar .filename::after {
                content: " v15";
                font-size: 0.7em;
                color: #888;
            }
            #toolbar .stats {
                color: #888;
                font-size: 0.85em;
            }
            #toolbar button {
                background: #2a2a4a;
                border: 1px solid #444;
                color: #ccc;
                padding: 4px 12px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 0.85em;
            }
            #toolbar button:hover {
                background: #3a3a5a;
            }
            #toolbar button:disabled {
                opacity: 0.4;
                cursor: not-allowed;
            }
            #toolbar select {
                background: #2a2a4a;
                border: 1px solid #444;
                color: #ccc;
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 0.85em;
            }

            #tooltip {
                display: none;
                position: fixed;
                background: #222244;
                border: 1px solid #555;
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 0.8em;
                pointer-events: none;
                z-index: 100;
                max-width: 320px;
                line-height: 1.5;
            }
            #tooltip .label {
                color: #888;
            }
            #tooltip .value {
                color: #fff;
                font-weight: 600;
            }

            #main-area {
                flex: 1;
                display: flex;
                flex-direction: column;
                overflow: hidden;
                position: relative;
            }

            #timeline-header {
                height: 30px;
                background: #16213e;
                border-bottom: 1px solid #333;
                flex-shrink: 0;
                position: relative;
                overflow: hidden;
            }

            #lanes-container {
                flex: 1;
                overflow-y: auto;
                overflow-x: hidden;
                position: relative;
            }

            #task-detail {
                display: none;
                height: 160px;
                background: #16213e;
                border-top: 1px solid #333;
                flex-shrink: 0;
                position: relative;
                overflow: hidden;
            }
            #task-detail .chart-label {
                position: absolute;
                top: 4px;
                left: 8px;
                font-size: 0.75em;
                color: #888;
                z-index: 2;
            }

            #queue-chart {
                height: 120px;
                background: #16213e;
                border-top: 1px solid #333;
                flex-shrink: 0;
                position: relative;
                overflow: hidden;
            }
            #queue-chart .chart-label {
                position: absolute;
                top: 4px;
                left: 8px;
                font-size: 0.75em;
                color: #888;
                z-index: 2;
            }

            .lane {
                height: 60px;
                border-bottom: 1px solid #222;
                position: relative;
                display: flex;
            }
            .lane-label {
                width: 100px;
                flex-shrink: 0;
                display: flex;
                align-items: center;
                padding-left: 12px;
                font-size: 0.8em;
                color: #aaa;
                background: #16213e;
                border-right: 1px solid #333;
                z-index: 1;
            }
            .lane-content {
                flex: 1;
                position: relative;
                overflow: hidden;
            }

            canvas {
                display: block;
            }
        </style>
    </head>
    <body>
        <div id="drop-zone">
            <div>
                <div style="font-size: 2em; margin-bottom: 12px">ðŸ“Š</div>
                <div>
                    Drop a <code>.bin</code> trace file here or click to open
                </div>
                <div style="font-size: 0.8em; margin-top: 8px; color: #666">
                    Expects TOKIOTRC binary format
                </div>
            </div>
            <input type="file" id="file-input" accept=".bin" />
        </div>

        <div id="viewer">
            <div id="toolbar">
                <span class="filename" id="tb-filename"></span>
                <span class="stats" id="tb-stats"></span>
                <span style="flex: 1"></span>
                <select id="poi-filter">
                    <option value="sched">Kernel Scheduling Delays</option>
                    <option value="long-poll">Long Polls (>1ms)</option>
                    <option value="wake-delay">Wakeâ†’Poll Delays (>100Âµs)</option>
                </select>
                <label style="display:flex;align-items:center;gap:4px;font-size:0.85em;cursor:pointer">
                    <input type="checkbox" id="sort-by-worst" style="cursor:pointer">
                    Worst first
                </label>
                <button id="btn-prev-poi">â—€ Prev</button>
                <button id="btn-next-poi">Next â–¶</button>
                <span id="poi-counter" style="font-size:0.85em;color:#888"></span>
                <span style="width:1px;height:20px;background:#444;margin:0 8px"></span>
                <button id="btn-zoom-in">Zoom +</button>
                <button id="btn-zoom-out">Zoom âˆ’</button>
                <button id="btn-fit">Fit All</button>
                <button id="btn-reset">New File</button>
            </div>
            <div id="main-area">
                <div id="timeline-header">
                    <canvas id="timeline-canvas"></canvas>
                </div>
                <div id="lanes-container" id="lanes"></div>
                <div id="task-detail">
                    <span class="chart-label" id="task-detail-label">Task Detail</span>
                    <canvas id="task-detail-canvas"></canvas>
                </div>
                <div id="queue-chart">
                    <span class="chart-label"
                        >Queue Depth (global=blue, local max=orange)</span
                    >
                    <canvas id="queue-canvas"></canvas>
                </div>
            </div>
        </div>

        <div id="tooltip"></div>

        <script>
            // â”€â”€ Binary Parser (v9 format) â”€â”€
            // Wire codes:
            //   0: PollStart        â†’ code(1) + ts(4) + worker(1) + local_q(1) + task_id(4) + spawn_loc_id(2) = 13 bytes
            //   1: PollEnd          â†’ code(1) + ts(4) + worker(1)                                              = 6 bytes
            //   2: WorkerPark       â†’ code(1) + ts(4) + worker(1) + local_q(1) + cpu_us(4)                    = 11 bytes
            //   3: WorkerUnpark     â†’ code(1) + ts(4) + worker(1) + local_q(1) + cpu_us(4) + sched_wait_us(4) = 15 bytes
            //   4: QueueSample      â†’ code(1) + ts(4) + global_q(1)                                           = 6 bytes
            //   5: SpawnLocationDef â†’ code(1) + spawn_loc_id(2) + string_len(2) + string_bytes(N)
            //   6: TaskSpawn        â†’ code(1) + task_id(4) + spawn_loc_id(2)                                  = 7 bytes
            //   7: WakeEvent        â†’ code(1) + ts(4) + waker_task_id(4) + woken_task_id(4) + target_worker(1) = 14 bytes
            const MAX_EVENTS = 2_000_000; // cap parsed events to keep UI responsive

            function parseTrace(buffer) {
                const view = new DataView(buffer);
                let off = 0;
                const magic = String.fromCharCode(
                    ...new Uint8Array(buffer, 0, 8),
                );
                off += 8;
                const version = view.getUint32(off, true);
                off += 4;
                if (magic !== "TOKIOTRC")
                    throw new Error("Not a TOKIOTRC file (got: " + magic + ")");
                if (version !== 8 && version !== 9) {
                    console.warn(`Expected version 8 or 9, got ${version}. Some data may be missing.`);
                }
                const hasCpuTime = version >= 5;
                const hasSchedWait = version >= 6;
                const hasTaskTracking = version >= 7;

                const events = [];
                const spawnLocations = new Map(); // SpawnLocationId (number) â†’ string
                const taskSpawnLocs = new Map();  // taskId (number) â†’ SpawnLocationId (number)
                const decoder = new TextDecoder();
                while (off < buffer.byteLength && events.length < MAX_EVENTS) {
                    if (off + 1 > buffer.byteLength) break;
                    const wireCode = view.getUint8(off);
                    off += 1;

                    // SpawnLocationDef and TaskSpawn have no timestamp â€” handle before reading ts
                    if (wireCode === 5) {
                        if (off + 4 > buffer.byteLength) break;
                        const spawnLocId = view.getUint16(off, true); off += 2;
                        const strLen = view.getUint16(off, true); off += 2;
                        if (off + strLen > buffer.byteLength) break;
                        spawnLocations.set(spawnLocId, decoder.decode(new Uint8Array(buffer, off, strLen)));
                        off += strLen;
                        continue;
                    }
                    if (wireCode === 6) {
                        if (off + 6 > buffer.byteLength) break;
                        const taskId = view.getUint32(off, true); off += 4;
                        const spawnLocId = view.getUint16(off, true); off += 2;
                        taskSpawnLocs.set(taskId, spawnLocId);
                        continue;
                    }

                    if (wireCode === 7) {
                        // WakeEvent: ts(4) + waker_task_id(4) + woken_task_id(4) + target_worker(1) = 13 after code
                        if (off + 13 > buffer.byteLength) break;
                        const timestampUs = view.getUint32(off, true); off += 4;
                        const wakerTaskId = view.getUint32(off, true); off += 4;
                        const wokenTaskId = view.getUint32(off, true); off += 4;
                        const targetWorker = view.getUint8(off); off += 1;
                        events.push({
                            eventType: 7, // WakeEvent
                            timestamp: timestampUs * 1000,
                            workerId: targetWorker,
                            wakerTaskId,
                            wokenTaskId,
                            targetWorker,
                            globalQueue: 0, localQueue: 0, cpuTime: 0, schedWait: 0,
                            taskId: 0, spawnLocId: 0, spawnLoc: null,
                        });
                        continue;
                    }

                    if (wireCode > 7) break; // unknown code

                    // All regular codes have a 4-byte timestamp next
                    if (off + 4 > buffer.byteLength) break;
                    const timestampUs = view.getUint32(off, true);
                    off += 4;
                    const timestamp = timestampUs * 1000;

                    let eventType,
                        workerId = 0,
                        globalQueue = 0,
                        localQueue = 0,
                        cpuTime = 0,
                        schedWait = 0,
                        taskId = 0,
                        spawnLocId = 0;
                    switch (wireCode) {
                        case 0: // PollStart
                            if (hasTaskTracking) {
                                // v8: worker(1) + lq(1) + task_id(4) + spawn_loc_id(2) = 8
                                if (off + 8 > buffer.byteLength) break;
                                eventType = 0;
                                workerId = view.getUint8(off); off += 1;
                                localQueue = view.getUint8(off); off += 1;
                                taskId = view.getUint32(off, true); off += 4;
                                spawnLocId = view.getUint16(off, true); off += 2;
                            } else {
                                if (off + 1 > buffer.byteLength) break;
                                eventType = 0;
                                workerId = view.getUint8(off); off += 1;
                            }
                            break;
                        case 1: // PollEnd
                            if (off + 1 > buffer.byteLength) break;
                            eventType = 1;
                            workerId = view.getUint8(off); off += 1;
                            break;
                        case 2: { // WorkerPark
                            const need = hasCpuTime ? 6 : 2;
                            if (off + need > buffer.byteLength) break;
                            eventType = 2;
                            workerId = view.getUint8(off); off += 1;
                            localQueue = view.getUint8(off); off += 1;
                            if (hasCpuTime) {
                                cpuTime = view.getUint32(off, true) * 1000; off += 4;
                            }
                            break;
                        }
                        case 3: { // WorkerUnpark
                            const need = hasCpuTime ? (hasSchedWait ? 10 : 6) : 2;
                            if (off + need > buffer.byteLength) break;
                            eventType = 3;
                            workerId = view.getUint8(off); off += 1;
                            localQueue = view.getUint8(off); off += 1;
                            if (hasCpuTime) {
                                cpuTime = view.getUint32(off, true) * 1000; off += 4;
                            }
                            if (hasSchedWait) {
                                schedWait = view.getUint32(off, true); off += 4;
                            }
                            break;
                        }
                        case 4: // QueueSample
                            if (off + 1 > buffer.byteLength) break;
                            eventType = 4;
                            globalQueue = view.getUint8(off); off += 1;
                            break;
                    }
                    events.push({
                        eventType, timestamp, workerId,
                        globalQueue, localQueue, cpuTime, schedWait,
                        taskId, spawnLocId,
                        spawnLoc: spawnLocations.get(spawnLocId) ?? null,
                    });
                }
                return { magic, version, events, truncated: events.length >= MAX_EVENTS, hasCpuTime, hasSchedWait, hasTaskTracking, spawnLocations, taskSpawnLocs };
            }

            // â”€â”€ Event type helpers â”€â”€
            const ET = {
                PollStart: 0,
                PollEnd: 1,
                WorkerPark: 2,
                WorkerUnpark: 3,
                QueueSample: 4,
                WakeEvent: 7,
            };
            const ET_NAMES = [
                "PollStart",
                "PollEnd",
                "WorkerPark",
                "WorkerUnpark",
                "QueueSample",
            ];
            const ET_COLORS = { poll: "#4fc3f7", park: "#ff8a65" };

            // â”€â”€ State â”€â”€
            let trace = null;
            let workerIds = [];
            let minTs = 0,
                maxTs = 0,
                durationNs = 0;
            // View window in nanoseconds
            let viewStart = 0,
                viewEnd = 0;
            // Precomputed spans per worker: { polls: [{start,end}], parks: [{start,end}] }
            let workerSpans = {};
            // Queue depth samples sorted by time
            let queueSamples = [];
            // Per-worker local queue samples
            let workerQueueSamples = {};
            let maxLocalQueue = 1;
            // Points of interest for navigation
            let pointsOfInterest = [];
            let currentPoiIndex = -1;
            // Task selection state
            let selectedTaskId = null;
            // Hovered waker task in task detail panel
            let hoveredWakerTaskId = null;
            // Stored wake hit regions for task detail mouseover: [{x1, x2, y1, y2, wakerTaskId}]
            let taskDetailWakeRegions = [];
            // Wake events indexed by woken task ID
            let wakesByTask = {}; // taskId â†’ [{timestamp, wakerTaskId, targetWorker}]
            // Wake events indexed by target worker
            let wakesByWorker = {}; // workerId â†’ [{timestamp, wakerTaskId, wokenTaskId}]
            // Scheduling delays: wake â†’ next poll for same task
            let schedDelays = []; // [{wakeTime, pollTime, delay, taskId, wakerTaskId, worker}]

            const LABEL_W = 100;
            const LANE_H = 60;

            // â”€â”€ DOM refs â”€â”€
            const dropZone = document.getElementById("drop-zone");
            const fileInput = document.getElementById("file-input");
            const viewer = document.getElementById("viewer");
            const tooltip = document.getElementById("tooltip");
            const timelineCanvas = document.getElementById("timeline-canvas");
            const queueCanvas = document.getElementById("queue-canvas");
            const lanesContainer = document.getElementById("lanes-container");

            // â”€â”€ File loading â”€â”€
            dropZone.addEventListener("click", () => fileInput.click());
            dropZone.addEventListener("dragover", (e) => {
                e.preventDefault();
                dropZone.classList.add("dragover");
            });
            dropZone.addEventListener("dragleave", () =>
                dropZone.classList.remove("dragover"),
            );
            dropZone.addEventListener("drop", (e) => {
                e.preventDefault();
                dropZone.classList.remove("dragover");
                loadFile(e.dataTransfer.files[0]);
            });
            fileInput.addEventListener("change", (e) => {
                if (e.target.files[0]) loadFile(e.target.files[0]);
            });
            document
                .getElementById("btn-reset")
                .addEventListener("click", () => {
                    viewer.style.display = "none";
                    dropZone.style.display = "flex";
                });

            function loadFile(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        trace = parseTrace(e.target.result);
                        processTrace();
                        showViewer(file.name);
                    } catch (err) {
                        alert("Error: " + err.message);
                    }
                };
                // Only read first 20MB â€” parser caps at MAX_EVENTS anyway
                const maxBytes = 20 * 1024 * 1024;
                const blob = file.size > maxBytes ? file.slice(0, maxBytes) : file;
                reader.readAsArrayBuffer(blob);
            }

            function processTrace() {
                const evts = trace.events;
                if (!evts.length) {
                    alert("No events in trace");
                    return;
                }

                const wSet = new Set();
                evts.forEach((e) => {
                    if (e.eventType !== ET.QueueSample && e.eventType !== ET.WakeEvent) wSet.add(e.workerId);
                });
                workerIds = [...wSet].sort((a, b) => a - b);

                minTs = evts[0].timestamp;
                maxTs = evts[evts.length - 1].timestamp;
                // Scan for true min/max in case events aren't sorted
                for (const e of evts) {
                    if (e.timestamp < minTs) minTs = e.timestamp;
                    if (e.timestamp > maxTs) maxTs = e.timestamp;
                }
                durationNs = maxTs - minTs || 1;
                viewStart = minTs;
                viewEnd = maxTs;

                // Build spans
                workerSpans = {};
                const openPoll = {},
                    openPark = {},
                    openUnpark = {}; // track {timestamp, cpuTime} at unpark
                const openPollMeta = {}; // track {taskId, spawnLocId} at PollStart
                for (const w of workerIds) {
                    workerSpans[w] = { polls: [], parks: [], actives: [] };
                }

                // Group events by worker and sort per-worker by timestamp
                // (events arrive in flush order, not global timestamp order)
                const perWorker = {};
                const globalEvts = []; // QueueSample etc
                for (const e of evts) {
                    if (e.eventType === ET.QueueSample || e.eventType === ET.WakeEvent) {
                        globalEvts.push(e);
                    } else {
                        (perWorker[e.workerId] ??= []).push(e);
                    }
                }
                for (const wEvents of Object.values(perWorker)) {
                    wEvents.sort((a, b) => a.timestamp - b.timestamp);
                }

                for (const [w, wEvents] of Object.entries(perWorker)) {
                    for (const e of wEvents) {
                        if (e.eventType === ET.PollStart) {
                            openPoll[w] = e.timestamp;
                            openPollMeta[w] = { taskId: e.taskId, spawnLocId: e.spawnLocId, spawnLoc: e.spawnLoc };
                        } else if (e.eventType === ET.PollEnd) {
                            if (openPoll[w] != null) {
                                const meta = openPollMeta[w] || { taskId: 0, spawnLocId: 0, spawnLoc: null };
                                workerSpans[w].polls.push({
                                    start: openPoll[w],
                                    end: e.timestamp,
                                    taskId: meta.taskId,
                                    spawnLocId: meta.spawnLocId,
                                    spawnLoc: meta.spawnLoc,
                                });
                                openPoll[w] = null;
                            }
                        } else if (e.eventType === ET.WorkerPark) {
                            openPark[w] = e.timestamp;
                            // Close active period
                            if (openUnpark[w] != null) {
                                const wallDelta = e.timestamp - openUnpark[w].timestamp;
                                const cpuDelta = e.cpuTime - openUnpark[w].cpuTime;
                                const ratio = wallDelta > 0 ? Math.min(cpuDelta / wallDelta, 1.0) : 1.0;
                                workerSpans[w].actives.push({
                                    start: openUnpark[w].timestamp,
                                    end: e.timestamp,
                                    ratio,
                                });
                                openUnpark[w] = null;
                            }
                        } else if (e.eventType === ET.WorkerUnpark) {
                            if (openPark[w] != null) {
                                workerSpans[w].parks.push({
                                    start: openPark[w],
                                    end: e.timestamp,
                                    schedWait: e.schedWait,
                                });
                                openPark[w] = null;
                            }
                            openUnpark[w] = { timestamp: e.timestamp, cpuTime: e.cpuTime };
                        }
                    }
                }
                // Close any open spans at trace end
                for (const w of workerIds) {
                    if (openPoll[w] != null)
                        workerSpans[w].polls.push({
                            start: openPoll[w],
                            end: maxTs,
                        });
                    if (openPark[w] != null)
                        workerSpans[w].parks.push({
                            start: openPark[w],
                            end: maxTs,
                        });
                }

                // Debug: log active period stats
                for (const w of workerIds) {
                    const a = workerSpans[w].actives;
                    console.log(`Worker ${w}: ${a.length} active periods` +
                        (a.length > 0 ? `, first ratio=${a[0].ratio.toFixed(3)}` : ''));
                }

                // Global queue samples (from QueueSample events only)
                queueSamples = evts
                    .filter((e) => e.eventType === ET.QueueSample)
                    .map((e) => ({ t: e.timestamp, global: e.globalQueue }));
                console.log(`Found ${queueSamples.length} global queue samples`);

                // Per-worker local queue samples (from events that have local_queue)
                workerQueueSamples = {};
                maxLocalQueue = 1;
                for (const w of workerIds) {
                    workerQueueSamples[w] = [];
                }
                for (const [w, wEvents] of Object.entries(perWorker)) {
                    for (const e of wEvents) {
                        if (e.eventType === ET.PollStart || e.eventType === ET.WorkerPark || e.eventType === ET.WorkerUnpark) {
                            workerQueueSamples[w] ??= [];
                            workerQueueSamples[w].push({
                                t: e.timestamp,
                                local: e.localQueue,
                            });
                            if (e.localQueue > maxLocalQueue)
                                maxLocalQueue = e.localQueue;
                        }
                    }
                }

                // Index wake events by woken task ID
                wakesByTask = {};
                for (const e of evts) {
                    if (e.eventType === ET.WakeEvent) {
                        (wakesByTask[e.wokenTaskId] ??= []).push({
                            timestamp: e.timestamp,
                            wakerTaskId: e.wakerTaskId,
                            targetWorker: e.targetWorker,
                        });
                    }
                }
                for (const arr of Object.values(wakesByTask)) {
                    arr.sort((a, b) => a.timestamp - b.timestamp);
                }

                // Index wake events by target worker
                wakesByWorker = {};
                for (const e of evts) {
                    if (e.eventType === ET.WakeEvent) {
                        (wakesByWorker[e.targetWorker] ??= []).push({
                            timestamp: e.timestamp,
                            wakerTaskId: e.wakerTaskId,
                            wokenTaskId: e.wokenTaskId,
                        });
                    }
                }
                for (const arr of Object.values(wakesByWorker)) {
                    arr.sort((a, b) => a.timestamp - b.timestamp);
                }

                // Compute scheduling delays: for each poll, find the most recent wake before it
                schedDelays = [];
                for (const w of workerIds) {
                    for (const s of workerSpans[w].polls) {
                        if (!s.taskId) continue;
                        const wakes = wakesByTask[s.taskId];
                        if (!wakes || !wakes.length) continue;
                        // Binary search for last wake <= s.start
                        let lo = 0, hi = wakes.length - 1, best = -1;
                        while (lo <= hi) {
                            const mid = (lo + hi) >> 1;
                            if (wakes[mid].timestamp <= s.start) { best = mid; lo = mid + 1; }
                            else hi = mid - 1;
                        }
                        if (best >= 0) {
                            const wake = wakes[best];
                            const delay = s.start - wake.timestamp;
                            if (delay > 0 && delay < 1e9) { // sanity: < 1s
                                schedDelays.push({
                                    wakeTime: wake.timestamp,
                                    pollTime: s.start,
                                    delay,
                                    taskId: s.taskId,
                                    wakerTaskId: wake.wakerTaskId,
                                    worker: w,
                                    poll: s,
                                });
                            }
                        }
                    }
                }
                schedDelays.sort((a, b) => a.wakeTime - b.wakeTime);
                console.log(`Found ${Object.keys(wakesByTask).length} tasks with wake events, ${schedDelays.length} scheduling delays`);
            }

            function showViewer(filename) {
                dropZone.style.display = "none";
                viewer.style.display = "flex";
                document.getElementById("tb-filename").textContent = filename;
                const durMs = durationNs / 1e6;
                const truncNote = trace.truncated ? " (truncated)" : "";
                document.getElementById("tb-stats").textContent =
                    `${trace.events.length.toLocaleString()} events Â· ${workerIds.length} workers Â· ${durMs.toFixed(1)}ms${truncNote}`;

                buildLanes();
                updatePointsOfInterest();
                requestAnimationFrame(renderAll);
            }

            function updatePointsOfInterest() {
                const filterType = document.getElementById("poi-filter").value;
                pointsOfInterest = [];
                
                for (const w of workerIds) {
                    const spans = workerSpans[w];
                    
                    if (filterType === "sched") {
                        // Find parks with scheduling delays > 100Âµs
                        for (const s of spans.parks) {
                            if (trace.hasSchedWait && s.schedWait > 100) {
                                const schedWaitNs = s.schedWait * 1000;
                                const wakeupShouldBe = s.end - schedWaitNs;
                                pointsOfInterest.push({
                                    time: wakeupShouldBe,
                                    worker: w,
                                    type: "sched",
                                    value: s.schedWait,
                                    span: s
                                });
                            }
                        }
                    } else if (filterType === "long-poll") {
                        // Polls longer than 1ms
                        for (const s of spans.polls) {
                            const durMs = (s.end - s.start) / 1e6;
                            if (durMs > 1) {
                                pointsOfInterest.push({
                                    time: s.start,
                                    worker: w,
                                    type: "long-poll",
                                    value: durMs,
                                    span: s
                                });
                            }
                        }
                    }
                }

                if (filterType === "wake-delay") {
                    // Wakeâ†’Poll scheduling delays > 100Âµs
                    for (const sd of schedDelays) {
                        const delayUs = sd.delay / 1000;
                        if (delayUs > 100) {
                            pointsOfInterest.push({
                                time: sd.wakeTime,
                                worker: sd.worker,
                                type: "wake-delay",
                                value: delayUs,
                                span: sd.poll,
                                schedDelay: sd,
                            });
                        }
                    }
                }
                
                // Sort by time or by worst value
                const sortByWorst = document.getElementById("sort-by-worst").checked;
                if (sortByWorst) {
                    pointsOfInterest.sort((a, b) => b.value - a.value);
                } else {
                    pointsOfInterest.sort((a, b) => a.time - b.time);
                }
                currentPoiIndex = -1;
                updatePoiCounter();
            }

            function updatePoiCounter() {
                const counter = document.getElementById("poi-counter");
                const prevBtn = document.getElementById("btn-prev-poi");
                const nextBtn = document.getElementById("btn-next-poi");
                
                if (pointsOfInterest.length === 0) {
                    counter.textContent = "None found";
                    prevBtn.disabled = true;
                    nextBtn.disabled = true;
                } else {
                    const idx = currentPoiIndex >= 0 ? currentPoiIndex + 1 : 0;
                    counter.textContent = `${idx}/${pointsOfInterest.length}`;
                    prevBtn.disabled = currentPoiIndex <= 0;
                    nextBtn.disabled = currentPoiIndex >= pointsOfInterest.length - 1;
                }
            }

            function jumpToPoi(index) {
                if (index < 0 || index >= pointsOfInterest.length) return;
                currentPoiIndex = index;
                const poi = pointsOfInterest[index];
                
                // Center view on this POI with appropriate zoom
                const spanDur = poi.span.end - poi.span.start;
                const viewDur = Math.max(spanDur * 5, 1e6); // Show 5x the span duration, min 1ms
                viewStart = Math.max(minTs, poi.time - viewDur * 0.3);
                viewEnd = Math.min(maxTs, viewStart + viewDur);

                // For wake-delay POIs, include the wake event in the view and select the task
                if (poi.schedDelay) {
                    const sd = poi.schedDelay;
                    const totalDur = sd.poll.end - sd.wakeTime;
                    const padded = Math.max(totalDur * 3, 1e6);
                    viewStart = Math.max(minTs, sd.wakeTime - padded * 0.2);
                    viewEnd = Math.min(maxTs, viewStart + padded);
                    selectedTaskId = sd.taskId;
                }
                
                // Scroll to worker lane
                const laneIdx = workerIds.indexOf(poi.worker);
                if (laneIdx >= 0) {
                    const scrollTop = laneIdx * LANE_H;
                    lanesContainer.scrollTop = scrollTop;
                }
                
                updatePoiCounter();
                renderAll();
            }

            // â”€â”€ Lane DOM â”€â”€
            let laneCanvases = {};
            function buildLanes() {
                lanesContainer.innerHTML = "";
                laneCanvases = {};
                for (const w of workerIds) {
                    const lane = document.createElement("div");
                    lane.className = "lane";
                    const label = document.createElement("div");
                    label.className = "lane-label";
                    label.textContent = `Worker ${w}`;
                    const content = document.createElement("div");
                    content.className = "lane-content";
                    const canvas = document.createElement("canvas");
                    canvas.id = `worker-${w}-canvas`;
                    content.appendChild(canvas);
                    lane.appendChild(label);
                    lane.appendChild(content);
                    lanesContainer.appendChild(lane);
                    laneCanvases[w] = canvas;
                }
            }

            // â”€â”€ Rendering â”€â”€
            let mouseNs = null; // Track mouse position for crosshair
            let queueChartRafId = null; // Throttle queue chart redraws
            function renderAll() {
                const rect = lanesContainer.getBoundingClientRect();
                const drawW = rect.width - LABEL_W;
                if (drawW <= 0) return;

                // Scrollbar width: difference between container and its usable content area
                const scrollbarW = lanesContainer.offsetWidth - lanesContainer.clientWidth;

                // First pass: calculate max visible queue across all workers
                window.visibleQueueRanges = {};
                let maxVisibleQ = 1;
                for (const w of workerIds) {
                    const samples = workerQueueSamples[w];
                    if (!samples || !samples.length) continue;
                    for (const s of samples) {
                        if (s.t >= viewStart && s.t <= viewEnd && s.local > maxVisibleQ) {
                            maxVisibleQ = s.local;
                        }
                    }
                }
                window.sharedVisibleMaxQ = maxVisibleQ;

                renderTimeline(drawW - scrollbarW);
                for (const w of workerIds) renderLane(w, drawW);
                renderTaskDetail(scrollbarW);
                renderQueueChart(drawW, scrollbarW);
            }

            function nsToX(ns, drawW) {
                return ((ns - viewStart) / (viewEnd - viewStart)) * drawW;
            }

            function renderTimeline(drawW) {
                const c = timelineCanvas;
                const parent = c.parentElement;
                const dpr = devicePixelRatio || 1;
                c.width = parent.clientWidth * dpr;
                c.height = 30 * dpr;
                c.style.width = parent.clientWidth + "px";
                c.style.height = "30px";
                const ctx = c.getContext("2d");
                ctx.scale(dpr, dpr);
                const w = parent.clientWidth;

                ctx.fillStyle = "#16213e";
                ctx.fillRect(0, 0, w, 30);

                const viewDur = viewEnd - viewStart;
                // Pick nice tick interval
                const targetTicks = Math.max(4, Math.floor(drawW / 100));
                const rawInterval = viewDur / targetTicks;
                const niceIntervals = [
                    1e3, 5e3, 1e4, 5e4, 1e5, 5e5, 1e6, 5e6, 1e7, 5e7, 1e8, 5e8,
                    1e9, 5e9, 1e10,
                ];
                let interval =
                    niceIntervals.find((i) => i >= rawInterval) || rawInterval;

                ctx.fillStyle = "#888";
                ctx.font = "10px monospace";
                ctx.textAlign = "center";
                ctx.strokeStyle = "#333";

                const firstTick = Math.ceil(viewStart / interval) * interval;
                for (let t = firstTick; t <= viewEnd; t += interval) {
                    const x = LABEL_W + nsToX(t, drawW);
                    ctx.beginPath();
                    ctx.moveTo(x, 20);
                    ctx.lineTo(x, 30);
                    ctx.stroke();
                    const relMs = (t - minTs) / 1e6;
                    let label;
                    if (relMs >= 1000) label = (relMs / 1000).toFixed(2) + "s";
                    else if (relMs >= 1) label = relMs.toFixed(2) + "ms";
                    else label = (relMs * 1000).toFixed(0) + "Âµs";
                    ctx.fillText(label, x, 16);
                }
            }

            function renderLane(workerId, drawW) {
                const c = laneCanvases[workerId];
                if (!c) {
                    console.error(`No canvas for worker ${workerId}`);
                    return;
                }
                const parent = c.parentElement;
                const dpr = devicePixelRatio || 1;
                const pw = parent.clientWidth,
                    ph = LANE_H;
                c.width = pw * dpr;
                c.height = ph * dpr;
                c.style.width = pw + "px";
                c.style.height = ph + "px";
                const ctx = c.getContext("2d");
                ctx.scale(dpr, dpr);

                const spans = workerSpans[workerId];

                // Background: active = dark, parked = distinct reddish-brown
                // First fill entire lane as "active" (dark)
                ctx.fillStyle = "#1a1e2a";
                ctx.fillRect(0, 0, pw, ph);

                // Color-code active periods by scheduling ratio (v5+ only)
                if (trace.hasCpuTime) {
                    for (const s of spans.actives) {
                        if (s.end < viewStart || s.start > viewEnd) continue;
                        const x1 = Math.max(0, nsToX(s.start, pw));
                        const x2 = Math.min(pw, nsToX(s.end, pw));
                        const w = Math.max(x2 - x1, 1);
                        if (s.ratio >= 0.95) {
                            ctx.fillStyle = "#1a2a1a"; // green tint â€” healthy
                        } else if (s.ratio >= 0.5) {
                            ctx.fillStyle = "#2a2a1a"; // yellow tint â€” some preemption
                        } else {
                            ctx.fillStyle = "#2a1a1a"; // red tint â€” heavily descheduled
                        }
                        ctx.fillRect(x1, 0, w, ph);
                    }
                }

                // Draw park spans â€” split into normal park (muted) and scheduling delay (bright red)
                for (const s of spans.parks) {
                    if (s.end < viewStart || s.start > viewEnd) continue;
                    const x1 = Math.max(0, nsToX(s.start, pw));
                    const x2 = Math.min(pw, nsToX(s.end, pw));
                    const w = Math.max(x2 - x1, 1);
                    
                    // If we have scheduling delay info, split the park visually
                    if (trace.hasSchedWait && s.schedWait > 0) {
                        const schedWaitNs = s.schedWait * 1000; // convert Âµs to ns
                        const wakeupShouldBe = s.end - schedWaitNs;
                        
                        // Normal park portion (before wakeup should have happened)
                        if (wakeupShouldBe > s.start) {
                            const xSplit = Math.min(pw, nsToX(wakeupShouldBe, pw));
                            const normalW = Math.max(xSplit - x1, 0);
                            if (normalW > 0) {
                                ctx.fillStyle = "#2a1520";
                                ctx.fillRect(x1, 0, normalW, ph);
                                ctx.fillStyle = "#cc5533";
                                ctx.fillRect(x1, 0, normalW, 4);
                            }
                            
                            // Scheduling delay portion (bright red)
                            const delayW = Math.max(x2 - xSplit, 0);
                            if (delayW > 0) {
                                ctx.fillStyle = "#ff0000";
                                ctx.fillRect(xSplit, 0, delayW, ph);
                            }
                        } else {
                            // Entire park is scheduling delay
                            ctx.fillStyle = "#ff0000";
                            ctx.fillRect(x1, 0, w, ph);
                        }
                    } else {
                        // No scheduling delay info, draw as normal park
                        ctx.fillStyle = "#2a1520";
                        ctx.fillRect(x1, 0, w, ph);
                        ctx.fillStyle = "#cc5533";
                        ctx.fillRect(x1, 0, w, 4);
                    }
                }

                // Draw poll spans (solid blue bars, center band)
                // When a task is selected, draw in two passes: dim first, selected on top
                const bandTop = 10,
                    bandH = 20;
                const poiSpan = (currentPoiIndex >= 0) ? pointsOfInterest[currentPoiIndex].span : null;
                if (selectedTaskId) {
                    ctx.fillStyle = "#2a3a4a";
                    for (const s of spans.polls) {
                        if (s.end < viewStart || s.start > viewEnd || s.taskId === selectedTaskId) continue;
                        const x1 = Math.max(0, nsToX(s.start, pw));
                        const x2 = Math.min(pw, nsToX(s.end, pw));
                        ctx.fillRect(x1, bandTop, Math.max(x2 - x1, 1), bandH);
                    }
                    ctx.fillStyle = "#ffeb3b";
                    for (const s of spans.polls) {
                        if (s.end < viewStart || s.start > viewEnd || s.taskId !== selectedTaskId) continue;
                        const x1 = Math.max(0, nsToX(s.start, pw));
                        const x2 = Math.min(pw, nsToX(s.end, pw));
                        ctx.fillRect(x1, bandTop, Math.max(x2 - x1, 1), bandH);
                    }
                } else {
                    ctx.fillStyle = "#4fc3f7";
                    for (const s of spans.polls) {
                        if (s.end < viewStart || s.start > viewEnd) continue;
                        const x1 = Math.max(0, nsToX(s.start, pw));
                        const x2 = Math.min(pw, nsToX(s.end, pw));
                        ctx.fillRect(x1, bandTop, Math.max(x2 - x1, 1), bandH);
                    }
                }
                // Highlight current POI span
                if (poiSpan) {
                    for (const s of spans.polls) {
                        if (s !== poiSpan || s.end < viewStart || s.start > viewEnd) continue;
                        const x1 = Math.max(0, nsToX(s.start, pw));
                        const x2 = Math.min(pw, nsToX(s.end, pw));
                        const w = Math.max(x2 - x1, 5);
                        ctx.fillStyle = "#ff4444";
                        ctx.fillRect(x1, bandTop, w, bandH);
                        ctx.strokeStyle = "#ffffff";
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x1, bandTop, w, bandH);
                    }
                }

                // Highlight hovered waker task's polls (orange)
                if (hoveredWakerTaskId) {
                    ctx.fillStyle = "#ff8a65";
                    for (const s of spans.polls) {
                        if (s.end < viewStart || s.start > viewEnd || s.taskId !== hoveredWakerTaskId) continue;
                        const x1 = Math.max(0, nsToX(s.start, pw));
                        const x2 = Math.min(pw, nsToX(s.end, pw));
                        ctx.fillRect(x1, bandTop, Math.max(x2 - x1, 2), bandH);
                    }
                }

                // Draw wake event markers on this worker lane (only when a task is selected)
                if (selectedTaskId) {
                    const wakes = wakesByWorker[workerId];
                    if (wakes && wakes.length) {
                        ctx.fillStyle = "#66bb6a";
                        for (const w of wakes) {
                            if (w.timestamp < viewStart || w.timestamp > viewEnd) continue;
                            if (w.wokenTaskId !== selectedTaskId) continue;
                            const x = nsToX(w.timestamp, pw);
                            // Small downward triangle at top of lane
                            ctx.beginPath();
                            ctx.moveTo(x, 2);
                            ctx.lineTo(x - 3, 8);
                            ctx.lineTo(x + 3, 8);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }
                }

                // Overlay local queue depth as a step chart in the bottom portion
                const samples = workerQueueSamples[workerId];
                if (samples && samples.length) {
                    // Find visible range with one sample before and after for continuity
                    let iStart = 0,
                        iEnd = samples.length - 1;
                    // Find first sample >= viewStart
                    for (let i = 0; i < samples.length; i++) {
                        if (samples[i].t >= viewStart) {
                            iStart = Math.max(0, i - 1);
                            break;
                        }
                    }
                    // Find last sample <= viewEnd
                    for (let i = samples.length - 1; i >= 0; i--) {
                        if (samples[i].t <= viewEnd) {
                            iEnd = Math.min(samples.length - 1, i + 1);
                            break;
                        }
                    }

                    // Store visible range for later max calculation
                    if (!window.visibleQueueRanges) window.visibleQueueRanges = {};
                    window.visibleQueueRanges[workerId] = { iStart, iEnd };

                    const qTop = 34,
                        qH = ph - 38;

                    // Use shared max (calculated in renderAllLanes)
                    const laneMaxQ = window.sharedVisibleMaxQ || 1;

                    // Draw scale label
                    ctx.fillStyle = "#666";
                    ctx.font = "8px monospace";
                    ctx.textAlign = "left";
                    ctx.fillText("q:" + laneMaxQ, 2, qTop + 8);

                    // Draw step chart - stroke only, no fill to avoid artifacts
                    ctx.beginPath();
                    let started = false;
                    let lastY = qTop + qH;
                    for (let i = iStart; i <= iEnd; i++) {
                        const x = Math.max(0, Math.min(pw, nsToX(samples[i].t, pw)));
                        const y = qTop + qH - (samples[i].local / laneMaxQ) * qH;
                        
                        if (!started) {
                            ctx.moveTo(x, y);
                            started = true;
                        } else {
                            ctx.lineTo(x, lastY);
                            ctx.lineTo(x, y);
                        }
                        lastY = y;
                    }
                    ctx.lineTo(pw, lastY);
                    const colors = ["rgba(255,200,50,0.8)", "rgba(50,255,200,0.8)", "rgba(255,50,200,0.8)", "rgba(200,50,255,0.8)"];
                    ctx.strokeStyle = colors[workerId % colors.length];
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }

                // Separator line between poll band and queue area
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(0, 33);
                ctx.lineTo(pw, 33);
                ctx.stroke();
            }

            // Hit regions for task detail tooltip: [{x1, x2, y1, y2, type, detail}]
            let taskDetailHitRegions = [];

            function renderTaskDetail(scrollbarW) {
                const panel = document.getElementById("task-detail");
                const c = document.getElementById("task-detail-canvas");
                if (!selectedTaskId) {
                    panel.style.display = "none";
                    return;
                }

                // Collect all polls for this task across all workers, sorted by start time
                const polls = [];
                for (const w of workerIds) {
                    for (const s of workerSpans[w].polls) {
                        if (s.taskId === selectedTaskId) polls.push(s);
                    }
                }
                polls.sort((a, b) => a.start - b.start);
                if (polls.length < 1) { panel.style.display = "none"; return; }

                // Get wake events for this task
                const wakes = wakesByTask[selectedTaskId] || [];

                panel.style.display = "block";
                const loc = trace.spawnLocations.get(polls[0].spawnLocId);
                const wakeCount = wakes.length;
                document.getElementById("task-detail-label").textContent =
                    `Task 0x${selectedTaskId.toString(16)}${loc ? " â€” " + loc : ""} Â· ${polls.length} polls Â· ${wakeCount} wakes`;

                const parent = c.parentElement;
                const dpr = devicePixelRatio || 1;
                const pw = parent.clientWidth, ph = parent.clientHeight;
                c.width = pw * dpr;
                c.height = ph * dpr;
                c.style.width = pw + "px";
                c.style.height = ph + "px";
                const ctx = c.getContext("2d");
                ctx.scale(dpr, dpr);

                ctx.fillStyle = "#16213e";
                ctx.fillRect(0, 0, pw, ph);

                // Account for scrollbar: draw area must match lane canvas width
                const drawW = pw - LABEL_W - (scrollbarW || 0);
                if (drawW <= 0) return;

                function fmtDur(ns) {
                    if (ns >= 1e6) return (ns / 1e6).toFixed(2) + "ms";
                    if (ns >= 1e3) return (ns / 1e3).toFixed(1) + "Âµs";
                    return ns.toFixed(0) + "ns";
                }

                const bandTop = 50, bandH = 30;
                ctx.font = "9px monospace";
                ctx.textAlign = "center";

                // For each poll, find the most recent wake before it to show wakeâ†’poll delay
                const pollWakes = []; // parallel to polls: the wake that triggered each poll (or null)
                for (const s of polls) {
                    let best = null;
                    if (wakes.length) {
                        let lo = 0, hi = wakes.length - 1, bi = -1;
                        while (lo <= hi) {
                            const mid = (lo + hi) >> 1;
                            if (wakes[mid].timestamp <= s.start) { bi = mid; lo = mid + 1; }
                            else hi = mid - 1;
                        }
                        if (bi >= 0) {
                            const w = wakes[bi];
                            const delay = s.start - w.timestamp;
                            if (delay >= 0 && delay < 1e9) best = w;
                        }
                    }
                    pollWakes.push(best);
                }

                // Draw wakeâ†’poll scheduling delay regions
                taskDetailWakeRegions = [];
                taskDetailHitRegions = [];
                for (let i = 0; i < polls.length; i++) {
                    const wake = pollWakes[i];
                    if (!wake) continue;
                    const s = polls[i];
                    if (s.start < viewStart || wake.timestamp > viewEnd) continue;
                    const delay = s.start - wake.timestamp;
                    const x1 = LABEL_W + Math.max(0, nsToX(wake.timestamp, drawW));
                    const x2 = LABEL_W + Math.min(drawW, nsToX(s.start, drawW));
                    const w = x2 - x1;
                    if (w < 1) continue;

                    // Color by severity
                    const delayUs = delay / 1000;
                    if (delayUs > 1000) ctx.fillStyle = "rgba(255,50,50,0.3)";
                    else if (delayUs > 100) ctx.fillStyle = "rgba(255,150,50,0.3)";
                    else ctx.fillStyle = "rgba(100,200,100,0.15)";
                    ctx.fillRect(x1, bandTop, w, bandH);

                    // Dashed border
                    ctx.strokeStyle = delayUs > 1000 ? "#ff4444" : delayUs > 100 ? "#ff8a65" : "#555";
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.strokeRect(x1, bandTop, w, bandH);
                    ctx.setLineDash([]);

                    // Delay label above
                    if (w > 25) {
                        ctx.fillStyle = delayUs > 1000 ? "#ff4444" : delayUs > 100 ? "#ff8a65" : "#888";
                        ctx.fillText(fmtDur(delay), x1 + w / 2, bandTop - 6);
                    }

                    // Wake marker (triangle)
                    const wx = x1;
                    ctx.fillStyle = "#66bb6a";
                    ctx.beginPath();
                    ctx.moveTo(wx, bandTop + bandH + 2);
                    ctx.lineTo(wx - 4, bandTop + bandH + 9);
                    ctx.lineTo(wx + 4, bandTop + bandH + 9);
                    ctx.closePath();
                    ctx.fill();

                    // Hit region for scheduled section
                    taskDetailHitRegions.push({
                        x1, x2: x1 + w, y1: bandTop, y2: bandTop + bandH,
                        type: "scheduled",
                        detail: `Scheduled â€” waiting ${fmtDur(delay)} for worker to poll after wake`,
                    });

                    // If woken by another task, show waker info
                    if (wake.wakerTaskId && wake.wakerTaskId !== 0) {
                        const wakerLoc = trace.taskSpawnLocs.get(wake.wakerTaskId);
                        const wakerLocStr = wakerLoc ? trace.spawnLocations.get(wakerLoc) : null;
                        const label = wakerLocStr
                            ? wakerLocStr.replace(/.*\//, '')
                            : null;
                        if (label && w > 40) {
                            const isHovered = hoveredWakerTaskId === wake.wakerTaskId;
                            ctx.fillStyle = isHovered ? "#fff" : "#66bb6a";
                            ctx.font = isHovered ? "bold 8px monospace" : "8px monospace";
                            ctx.textAlign = "left";
                            ctx.fillText("â¬† " + label, wx, bandTop + bandH + 20);
                            ctx.font = "9px monospace";
                            // Record hit region for hover detection
                            taskDetailWakeRegions.push({
                                x1, x2: x1 + w,
                                y1: bandTop + bandH, y2: bandTop + bandH + 24,
                                wakerTaskId: wake.wakerTaskId,
                            });
                        }
                    }
                }

                // Draw poll spans
                for (const s of polls) {
                    if (s.end < viewStart || s.start > viewEnd) continue;
                    const x1 = LABEL_W + Math.max(0, nsToX(s.start, drawW));
                    const x2 = LABEL_W + Math.min(drawW, nsToX(s.end, drawW));
                    const w = Math.max(x2 - x1, 1);
                    ctx.fillStyle = "#4fc3f7";
                    ctx.fillRect(x1, bandTop, w, bandH);
                    if (w > 35) {
                        ctx.fillStyle = "#000";
                        ctx.fillText(fmtDur(s.end - s.start), x1 + w / 2, bandTop + bandH / 2 + 3);
                    }
                    // Hit region for polling section
                    taskDetailHitRegions.push({
                        x1, x2, y1: bandTop, y2: bandTop + bandH,
                        type: "polling",
                        detail: `Polling â€” actively executing for ${fmtDur(s.end - s.start)}`,
                    });
                }

                // Draw idle gaps between consecutive polls (where no wakeâ†’poll delay is shown)
                for (let i = 0; i < polls.length - 1; i++) {
                    const gapStart = polls[i].end;
                    const gapEnd = polls[i + 1].start;
                    if (gapEnd < viewStart || gapStart > viewEnd) continue;
                    // Skip if the next poll's wake covers this gap
                    const nextWake = pollWakes[i + 1];
                    if (nextWake && nextWake.timestamp <= gapStart) continue;
                    const x1 = LABEL_W + Math.max(0, nsToX(gapStart, drawW));
                    const wakeX = nextWake ? LABEL_W + Math.max(0, nsToX(nextWake.timestamp, drawW)) : LABEL_W + Math.min(drawW, nsToX(gapEnd, drawW));
                    const x2 = Math.min(wakeX, LABEL_W + Math.min(drawW, nsToX(gapEnd, drawW)));
                    const w = Math.max(x2 - x1, 0);
                    if (w < 1) continue;
                    ctx.fillStyle = "#2a2a4a";
                    ctx.fillRect(x1, bandTop, w, bandH);
                    ctx.strokeStyle = "#444";
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]);
                    ctx.strokeRect(x1, bandTop, w, bandH);
                    ctx.setLineDash([]);
                    const dur = (nextWake ? nextWake.timestamp : gapEnd) - gapStart;
                    ctx.fillStyle = dur > 1e6 ? "#ff8a65" : "#888";
                    if (w > 35) {
                        ctx.fillText(fmtDur(dur), x1 + w / 2, bandTop - 6);
                    }
                    // Hit region for idle section
                    taskDetailHitRegions.push({
                        x1, x2, y1: bandTop, y2: bandTop + bandH,
                        type: "idle",
                        detail: `Idle â€” waiting ${fmtDur(dur)} for waker (no wake received yet)`,
                    });
                }

                // Legend
                ctx.fillStyle = "#aaa";
                ctx.font = "9px monospace";
                ctx.textAlign = "left";
                ctx.fillText("Task", 12, bandTop + bandH / 2 + 4);
                ctx.fillStyle = "#66bb6a";
                ctx.fillText("â–² = wake", 12, bandTop + bandH + 18);
            }

            function renderQueueChart(drawW, scrollbarW) {
                const c = queueCanvas;
                const parent = c.parentElement;
                const dpr = devicePixelRatio || 1;
                const pw = parent.clientWidth,
                    ph = parent.clientHeight;
                c.width = pw * dpr;
                c.height = ph * dpr;
                c.style.width = pw + "px";
                c.style.height = ph + "px";
                const ctx = c.getContext("2d");
                ctx.scale(dpr, dpr);

                ctx.fillStyle = "#16213e";
                ctx.fillRect(0, 0, pw, ph);

                if (!queueSamples.length) return;

                const chartLeft = LABEL_W,
                    chartW = pw - LABEL_W - (scrollbarW || 0);
                const chartTop = 24,
                    chartH = ph - 30;
                if (chartW <= 0) return;

                // Bucket samples into pixels â€” take max global and max local per pixel bucket
                const numBuckets = Math.ceil(chartW);
                const buckets = new Array(numBuckets);
                for (let i = 0; i < numBuckets; i++)
                    buckets[i] = { maxGlobal: 0, maxLocal: 0, hasData: false };

                const viewDur = viewEnd - viewStart;
                // Global queue from QueueSample events
                for (const s of queueSamples) {
                    if (s.t < viewStart || s.t > viewEnd) continue;
                    const bi = Math.floor(
                        ((s.t - viewStart) / viewDur) * (numBuckets - 1),
                    );
                    if (bi < 0 || bi >= numBuckets) continue;
                    const b = buckets[bi];
                    b.hasData = true;
                    if (s.global > b.maxGlobal) b.maxGlobal = s.global;
                }
                // Build sorted timeline of all local queue changes
                const allLocalSamples = [];
                for (const w of workerIds) {
                    const wSamples = workerQueueSamples[w] || [];
                    for (const s of wSamples) {
                        if (s.t >= viewStart && s.t <= viewEnd) {
                            allLocalSamples.push({ t: s.t, w, local: s.local });
                        }
                    }
                }
                allLocalSamples.sort((a, b) => a.t - b.t);
                
                // Single pass: maintain per-worker state and compute max for each bucket
                const workerState = {};
                for (const w of workerIds) workerState[w] = 0;
                let sampleIdx = 0;
                
                for (let bi = 0; bi < numBuckets; bi++) {
                    const bucketEnd = viewStart + ((bi + 1) / numBuckets) * viewDur;
                    
                    // Apply all samples up to this bucket's end
                    while (sampleIdx < allLocalSamples.length && allLocalSamples[sampleIdx].t < bucketEnd) {
                        const s = allLocalSamples[sampleIdx];
                        workerState[s.w] = s.local;
                        buckets[bi].hasData = true;
                        sampleIdx++;
                    }
                    
                    // Max across all workers
                    let max = 0;
                    for (const w of workerIds) {
                        if (workerState[w] > max) max = workerState[w];
                    }
                    buckets[bi].maxLocal = max;
                }

                // Find max for scaling
                let maxQ = 1;
                for (const b of buckets) {
                    if (b.maxGlobal > maxQ) maxQ = b.maxGlobal;
                    if (b.maxLocal > maxQ) maxQ = b.maxLocal;
                }

                // Y-axis labels
                ctx.fillStyle = "#666";
                ctx.font = "10px monospace";
                ctx.textAlign = "right";
                ctx.fillText(maxQ.toString(), LABEL_W - 6, chartTop + 10);
                ctx.fillText("0", LABEL_W - 6, chartTop + chartH);

                // Draw global queue as filled step area
                ctx.beginPath();
                ctx.moveTo(chartLeft, chartTop + chartH);
                let lastY = chartTop + chartH;
                for (let i = 0; i < numBuckets; i++) {
                    const x = chartLeft + i;
                    if (buckets[i].hasData) {
                        lastY =
                            chartTop +
                            chartH -
                            (buckets[i].maxGlobal / maxQ) * chartH;
                    }
                    ctx.lineTo(x, lastY);
                }
                ctx.lineTo(chartLeft + numBuckets - 1, chartTop + chartH);
                ctx.closePath();
                ctx.fillStyle = "rgba(79,195,247,0.3)";
                ctx.fill();
                ctx.strokeStyle = "#4fc3f7";
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw max local queue as step line
                ctx.beginPath();
                lastY = chartTop + chartH;
                let started = false;
                for (let i = 0; i < numBuckets; i++) {
                    const x = chartLeft + i;
                    if (buckets[i].hasData) {
                        lastY =
                            chartTop +
                            chartH -
                            (buckets[i].maxLocal / maxQ) * chartH;
                    }
                    if (!started) {
                        ctx.moveTo(x, lastY);
                        started = true;
                    } else ctx.lineTo(x, lastY);
                }
                ctx.strokeStyle = "#ff8a65";
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw crosshair if mouse is over worker lanes
                if (mouseNs !== null && mouseNs >= viewStart && mouseNs <= viewEnd) {
                    const x = chartLeft + ((mouseNs - viewStart) / viewDur) * chartW;
                    ctx.strokeStyle = "rgba(255,255,255,0.5)";
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(x, chartTop);
                    ctx.lineTo(x, chartTop + chartH);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // â”€â”€ Zoom & Pan â”€â”€
            document.getElementById("poi-filter").addEventListener("change", updatePointsOfInterest);
            document.getElementById("sort-by-worst").addEventListener("change", updatePointsOfInterest);
            document.getElementById("btn-prev-poi").addEventListener("click", () => {
                if (currentPoiIndex > 0) jumpToPoi(currentPoiIndex - 1);
                else if (currentPoiIndex < 0 && pointsOfInterest.length > 0) jumpToPoi(0);
            });
            document.getElementById("btn-next-poi").addEventListener("click", () => {
                if (currentPoiIndex < pointsOfInterest.length - 1) jumpToPoi(currentPoiIndex + 1);
                else if (currentPoiIndex < 0 && pointsOfInterest.length > 0) jumpToPoi(0);
            });
            document
                .getElementById("btn-zoom-in")
                .addEventListener("click", () => zoom(0.5));
            document
                .getElementById("btn-zoom-out")
                .addEventListener("click", () => zoom(2));
            document.getElementById("btn-fit").addEventListener("click", () => {
                viewStart = minTs;
                viewEnd = maxTs;
                renderAll();
            });

            function zoom(factor, centerFrac = 0.5) {
                const viewDur = viewEnd - viewStart;
                const center = viewStart + viewDur * centerFrac;
                const newDur = Math.max(viewDur * factor, 100); // min 100ns
                viewStart = Math.max(minTs, center - newDur * centerFrac);
                viewEnd = Math.min(maxTs, center + newDur * (1 - centerFrac));
                renderAll();
            }

            // Mouse wheel zoom on main area
            document.getElementById("main-area").addEventListener(
                "wheel",
                (e) => {
                    e.preventDefault();
                    const rect = lanesContainer.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left - LABEL_W;
                    const drawW = rect.width - LABEL_W;
                    const frac = Math.max(0, Math.min(1, mouseX / drawW));
                    const factor = e.deltaY > 0 ? 1.3 : 1 / 1.3;
                    zoom(factor, frac);
                },
                { passive: false },
            );

            // Pan with mouse drag
            let dragging = false,
                dragStartX = 0,
                dragViewStart = 0,
                dragViewEnd = 0,
                dragMoved = false;
            document
                .getElementById("main-area")
                .addEventListener("mousedown", (e) => {
                    dragging = true;
                    dragMoved = false;
                    dragStartX = e.clientX;
                    dragViewStart = viewStart;
                    dragViewEnd = viewEnd;
                    document.body.style.cursor = "grabbing";
                });
            window.addEventListener("mousemove", (e) => {
                if (!dragging) return;
                if (Math.abs(e.clientX - dragStartX) > 3) dragMoved = true;
                const rect = lanesContainer.getBoundingClientRect();
                const drawW = rect.width - LABEL_W;
                const dx = e.clientX - dragStartX;
                const nsPerPx = (dragViewEnd - dragViewStart) / drawW;
                const shift = -dx * nsPerPx;
                let newStart = dragViewStart + shift;
                let newEnd = dragViewEnd + shift;
                // Clamp
                if (newStart < minTs) {
                    newEnd += minTs - newStart;
                    newStart = minTs;
                }
                if (newEnd > maxTs) {
                    newStart -= newEnd - maxTs;
                    newEnd = maxTs;
                }
                viewStart = Math.max(minTs, newStart);
                viewEnd = Math.min(maxTs, newEnd);
                renderAll();
            });
            window.addEventListener("mouseup", () => {
                dragging = false;
                document.body.style.cursor = "";
            });

            // Click on a poll to highlight all polls for the same task
            document.getElementById("main-area").addEventListener("click", (e) => {
                if (dragMoved) return; // was a drag, not a click
                // Only handle clicks inside the lanes container
                const lanesRect = lanesContainer.getBoundingClientRect();
                if (e.clientY < lanesRect.top || e.clientY > lanesRect.bottom ||
                    e.clientX < lanesRect.left || e.clientX > lanesRect.right) return;
                const mouseX = e.clientX - lanesRect.left - LABEL_W;
                const mouseY = e.clientY - lanesRect.top;
                const drawW = lanesRect.width - LABEL_W;
                if (mouseX < 0 || mouseX > drawW) { selectedTaskId = null; renderAll(); return; }

                const ns = viewStart + (mouseX / drawW) * (viewEnd - viewStart);
                const laneIdx = Math.floor((mouseY + lanesContainer.scrollTop) / LANE_H);
                if (laneIdx < 0 || laneIdx >= workerIds.length) { selectedTaskId = null; renderAll(); return; }

                const w = workerIds[laneIdx];
                const spans = workerSpans[w];
                let found = null;
                for (const s of spans.polls) {
                    if (ns >= s.start && ns <= s.end && s.taskId) { found = s.taskId; break; }
                }
                selectedTaskId = (found && found !== selectedTaskId) ? found : null;
                renderAll();
            });

            // â”€â”€ Keyboard navigation â”€â”€
            window.addEventListener("keydown", (e) => {
                if (!trace) return;
                const viewDur = viewEnd - viewStart;
                switch (e.key) {
                    case "Escape":
                        e.preventDefault();
                        selectedTaskId = null;
                        renderAll();
                        break;
                    case "ArrowUp":
                        e.preventDefault();
                        zoom(0.5);
                        break;
                    case "ArrowDown":
                        e.preventDefault();
                        zoom(2);
                        break;
                    case "ArrowLeft": {
                        e.preventDefault();
                        const shift = viewDur * 0.2;
                        viewStart = Math.max(minTs, viewStart - shift);
                        viewEnd = viewStart + viewDur;
                        if (viewEnd > maxTs) {
                            viewEnd = maxTs;
                            viewStart = viewEnd - viewDur;
                        }
                        renderAll();
                        break;
                    }
                    case "ArrowRight": {
                        e.preventDefault();
                        const shift = viewDur * 0.2;
                        viewEnd = Math.min(maxTs, viewEnd + shift);
                        viewStart = viewEnd - viewDur;
                        if (viewStart < minTs) {
                            viewStart = minTs;
                            viewEnd = viewStart + viewDur;
                        }
                        renderAll();
                        break;
                    }
                }
            });

            // â”€â”€ Tooltip â”€â”€
            document
                .getElementById("main-area")
                .addEventListener("mousemove", (e) => {
                    if (dragging) {
                        tooltip.style.display = "none";
                        mouseNs = null;
                        return;
                    }
                    const rect = lanesContainer.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left - LABEL_W;
                    const mouseY = e.clientY - rect.top;
                    const drawW = rect.width - LABEL_W;
                    if (mouseX < 0 || mouseX > drawW) {
                        tooltip.style.display = "none";
                        mouseNs = null;
                        return;
                    }

                    const ns =
                        viewStart + (mouseX / drawW) * (viewEnd - viewStart);
                    mouseNs = ns;
                    
                    // Throttle queue chart redraw with RAF
                    if (!queueChartRafId) {
                        const sbW = lanesContainer.offsetWidth - lanesContainer.clientWidth;
                        queueChartRafId = requestAnimationFrame(() => {
                            renderQueueChart(drawW, sbW);
                            queueChartRafId = null;
                        });
                    }

                    const laneIdx = Math.floor(
                        (mouseY + lanesContainer.scrollTop) / LANE_H,
                    );
                    if (laneIdx < 0 || laneIdx >= workerIds.length) {
                        tooltip.style.display = "none";
                        return;
                    }

                    const w = workerIds[laneIdx];
                    const spans = workerSpans[w];
                    const relMs = (ns - minTs) / 1e6;

                    // Determine worker state at this point in time
                    let state = "ðŸŸ¢ Active";
                    let stateDetail = "";
                    let schedInfo = "";
                    if (trace.hasCpuTime) {
                        for (const s of spans.actives) {
                            if (ns >= s.start && ns <= s.end) {
                                const pct = (s.ratio * 100).toFixed(1);
                                const icon = s.ratio >= 0.95 ? "ðŸŸ¢" : s.ratio >= 0.5 ? "ðŸŸ¡" : "ðŸ”´";
                                schedInfo = `<span class="label">Scheduling:</span> <span class="value">${icon} ${pct}% on-CPU</span><br>`;
                                break;
                            }
                        }
                    }
                    for (const s of spans.parks) {
                        if (ns >= s.start && ns <= s.end) {
                            const durMs = (s.end - s.start) / 1e6;
                            state = "ðŸ’¤ Parked";
                            stateDetail = ` for <span class="value">${durMs < 1 ? (durMs * 1000).toFixed(1) + "Âµs" : durMs.toFixed(2) + "ms"}</span>`;
                            schedInfo = "";
                            if (trace.hasSchedWait && s.schedWait != null) {
                                const swUs = s.schedWait;
                                const icon = swUs < 100 ? "ðŸŸ¢" : swUs < 1000 ? "ðŸŸ¡" : "ðŸ”´";
                                stateDetail += `<br><span class="label">Kernel sched delay:</span> <span class="value">${icon} ${swUs.toFixed(0)}Âµs</span>`;
                            }
                            break;
                        }
                    }

                    let pollInfo = "";
                    for (const s of spans.polls) {
                        if (ns >= s.start && ns <= s.end) {
                            const durUs = (s.end - s.start) / 1e3;
                            state = "âš¡ Polling";
                            pollInfo = `<span class="label">Poll duration:</span> <span class="value">${durUs.toFixed(1)}Âµs</span><br>`;
                            if (trace.hasTaskTracking && s.taskId) {
                                pollInfo += `<span class="label">Task ID:</span> <span class="value">0x${s.taskId.toString(16)}</span><br>`;
                                if (s.spawnLoc) {
                                    pollInfo += `<span class="label">Spawned at:</span> <span class="value">${s.spawnLoc}</span><br>`;
                                }
                            }
                            break;
                        }
                    }

                    // Find nearest local queue sample for this worker
                    let nearest = null,
                        bestDist = Infinity;
                    const wSamples = workerQueueSamples[w] || [];
                    for (const s of wSamples) {
                        const d = Math.abs(s.t - ns);
                        if (d < bestDist) {
                            bestDist = d;
                            nearest = s;
                        }
                    }
                    // Find nearest global queue from QueueSample timeline
                    let nearestGlobal = null;
                    bestDist = Infinity;
                    for (const s of queueSamples) {
                        const d = Math.abs(s.t - ns);
                        if (d < bestDist) {
                            bestDist = d;
                            nearestGlobal = s;
                        }
                    }

                    let qInfo = "";
                    const globalStr = nearestGlobal != null ? nearestGlobal.global : "-";
                    const localStr = nearest != null ? nearest.local : "-";
                    const totalEst = (nearestGlobal != null ? nearestGlobal.global : 0) + (nearest != null ? nearest.local : 0);
                    qInfo = `<span class="label">Global Q:</span> <span class="value">${globalStr}</span> Â· <span class="label">Local Q:</span> <span class="value">${localStr}</span> Â· <span class="label">Est. Total:</span> <span class="value">${totalEst}</span>`;

                    tooltip.innerHTML =
                        `<span class="label">Worker</span> <span class="value">${w}</span> Â· <span class="label">Time</span> <span class="value">${relMs.toFixed(3)}ms</span><br>` +
                        `<span class="label">State:</span> ${state}${stateDetail}<br>` +
                        schedInfo +
                        pollInfo +
                        qInfo;
                    tooltip.style.display = "block";
                    tooltip.style.left =
                        Math.min(e.clientX + 12, window.innerWidth - 340) +
                        "px";
                    tooltip.style.top = e.clientY + 130 + "px";
                });
            document
                .getElementById("main-area")
                .addEventListener("mouseleave", () => {
                    tooltip.style.display = "none";
                    mouseNs = null;
                    renderAll();
                });

            // â”€â”€ Resize â”€â”€
            // Task detail hover: highlight waker task polls on worker lanes + section tooltips
            document.getElementById("task-detail").addEventListener("mousemove", (e) => {
                const c = document.getElementById("task-detail-canvas");
                const rect = c.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                let found = null;
                for (const r of taskDetailWakeRegions) {
                    if (mx >= r.x1 && mx <= r.x2 && my >= r.y1 && my <= r.y2) {
                        found = r.wakerTaskId;
                        break;
                    }
                }
                if (found !== hoveredWakerTaskId) {
                    hoveredWakerTaskId = found;
                    document.getElementById("task-detail").style.cursor = found ? "pointer" : "";
                    renderAll();
                }

                // Show tooltip for polling/scheduled/idle sections
                let hit = null;
                for (const r of taskDetailHitRegions) {
                    if (mx >= r.x1 && mx <= r.x2 && my >= r.y1 && my <= r.y2) {
                        hit = r;
                        break;
                    }
                }
                if (hit) {
                    const icon = hit.type === "polling" ? "âš¡" : hit.type === "scheduled" ? "â³" : "ðŸ’¤";
                    tooltip.innerHTML = `<span class="value">${icon} ${hit.detail}</span>`;
                    tooltip.style.display = "block";
                    tooltip.style.left = Math.min(e.clientX + 12, window.innerWidth - 340) + "px";
                    tooltip.style.top = (e.clientY - 40) + "px";
                } else {
                    tooltip.style.display = "none";
                }
            });
            document.getElementById("task-detail").addEventListener("mouseleave", () => {
                tooltip.style.display = "none";
                if (hoveredWakerTaskId) {
                    hoveredWakerTaskId = null;
                    renderAll();
                }
            });

            window.addEventListener("resize", () => {
                if (trace) renderAll();
            });

            // â”€â”€ Legend (inline in toolbar area) â”€â”€
            (function addLegend() {
                const tb = document.getElementById("toolbar");
                const leg = document.createElement("span");
                leg.style.cssText =
                    "font-size:0.8em;display:flex;gap:12px;align-items:center;";
                leg.innerHTML = `
    <span style="display:flex;align-items:center;gap:4px"><span style="width:12px;height:12px;background:#4fc3f7;display:inline-block;border-radius:2px"></span>Poll</span>
    <span style="display:flex;align-items:center;gap:4px"><span style="width:12px;height:12px;background:#2a1520;border-top:3px solid #cc5533;display:inline-block;border-radius:2px"></span>Parked</span>
    <span style="display:flex;align-items:center;gap:4px"><span style="width:12px;height:12px;background:#ff0000;display:inline-block;border-radius:2px"></span>Kernel Sched Delay</span>
    <span style="display:flex;align-items:center;gap:4px"><span style="color:#66bb6a;font-size:10px">â–¼</span>Wake</span>
    <span style="display:flex;align-items:center;gap:4px"><span style="width:12px;height:2px;background:rgba(255,200,50,0.7);display:inline-block"></span>Local Q</span>
    <span style="color:#666;margin-left:8px">â”‚ â†‘â†“ zoom Â· â†â†’ pan Â· click poll for task + wake timeline Â· esc close</span>
  `;
                tb.insertBefore(leg, document.getElementById("btn-zoom-in"));
            })();
        </script>
    </body>
</html>
