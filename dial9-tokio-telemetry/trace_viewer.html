<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Tokio Trace Viewer</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }
            body {
                font-family:
                    -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                    monospace;
                background: #1a1a2e;
                color: #e0e0e0;
                overflow: hidden;
                height: 100vh;
                display: flex;
                flex-direction: column;
            }

            #drop-zone {
                display: flex;
                align-items: center;
                justify-content: center;
                height: 100vh;
                width: 100vw;
                border: 3px dashed #444;
                border-radius: 12px;
                margin: 20px;
                font-size: 1.2em;
                color: #888;
                cursor: pointer;
                transition: all 0.2s;
            }
            #drop-zone:hover,
            #drop-zone.dragover {
                border-color: #6c63ff;
                color: #6c63ff;
                background: rgba(108, 99, 255, 0.05);
            }
            #drop-zone input {
                display: none;
            }

            #viewer {
                display: none;
                flex-direction: column;
                height: 100vh;
            }

            #toolbar {
                display: flex;
                align-items: center;
                gap: 12px;
                padding: 8px 16px;
                background: #16213e;
                border-bottom: 1px solid #333;
                flex-shrink: 0;
                min-height: 44px;
            }
            #toolbar .filename {
                font-weight: 600;
                color: #6c63ff;
            }
            #toolbar .filename::after {
                content: " v15";
                font-size: 0.7em;
                color: #888;
            }
            #toolbar .stats {
                color: #888;
                font-size: 0.85em;
            }
            #toolbar button {
                background: #2a2a4a;
                border: 1px solid #444;
                color: #ccc;
                padding: 4px 12px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 0.85em;
            }
            #toolbar button:hover {
                background: #3a3a5a;
            }
            #toolbar button:disabled {
                opacity: 0.4;
                cursor: not-allowed;
            }
            #toolbar select {
                background: #2a2a4a;
                border: 1px solid #444;
                color: #ccc;
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 0.85em;
            }

            #tooltip {
                display: none;
                position: fixed;
                background: #222244;
                border: 1px solid #555;
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 0.8em;
                pointer-events: none;
                z-index: 100;
                max-width: 320px;
                line-height: 1.5;
            }
            #tooltip .label {
                color: #888;
            }
            #tooltip .value {
                color: #fff;
                font-weight: 600;
            }

            #main-area {
                flex: 1;
                display: flex;
                flex-direction: column;
                overflow: hidden;
                position: relative;
            }

            #timeline-header {
                height: 30px;
                background: #16213e;
                border-bottom: 1px solid #333;
                flex-shrink: 0;
                position: relative;
                overflow: hidden;
            }

            #lanes-container {
                flex: 1;
                overflow-y: auto;
                overflow-x: hidden;
                position: relative;
            }

            #task-detail {
                display: none;
                height: 160px;
                background: #16213e;
                border-top: 1px solid #333;
                flex-shrink: 0;
                position: relative;
                overflow: hidden;
            }
            #task-detail .chart-label {
                position: absolute;
                top: 4px;
                left: 8px;
                font-size: 0.75em;
                color: #888;
                z-index: 2;
            }

            #queue-chart {
                height: 120px;
                background: #16213e;
                border-top: 1px solid #333;
                flex-shrink: 0;
                position: relative;
                overflow: hidden;
            }
            #queue-chart .chart-label {
                position: absolute;
                top: 4px;
                left: 8px;
                font-size: 0.75em;
                color: #888;
                z-index: 2;
            }

            .lane {
                height: 60px;
                border-bottom: 1px solid #222;
                position: relative;
                display: flex;
            }
            .lane-label {
                width: 100px;
                flex-shrink: 0;
                display: flex;
                align-items: center;
                padding-left: 12px;
                font-size: 0.8em;
                color: #aaa;
                background: #16213e;
                border-right: 1px solid #333;
                z-index: 1;
            }
            .lane-content {
                flex: 1;
                position: relative;
                overflow: hidden;
            }

            canvas {
                display: block;
            }

            #selection-overlay {
                position: absolute;
                background: rgba(108, 99, 255, 0.15);
                border: 1px solid rgba(108, 99, 255, 0.6);
                pointer-events: none;
                z-index: 9;
                display: none;
            }

            #flamegraph-panel {
                display: none;
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: #1a1a2e;
                z-index: 50;
                flex-direction: column;
            }
            #flamegraph-panel .fg-header {
                display: flex;
                align-items: center;
                gap: 12px;
                padding: 6px 12px;
                background: #16213e;
                border-bottom: 1px solid #333;
                font-size: 0.8em;
                flex-shrink: 0;
            }
            #flamegraph-panel .fg-header .fg-title { color: #6c63ff; font-weight: 600; }
            #flamegraph-panel .fg-header .fg-stats { color: #888; }
            #flamegraph-panel .fg-header .fg-close { cursor: pointer; color: #888; margin-left: auto; padding: 0 4px; }
            #flamegraph-panel .fg-header .fg-close:hover { color: #fff; }
            .fg-section-label {
                padding: 4px 12px;
                font-size: 0.78em;
                color: #aaa;
                background: #16213e;
                border-bottom: 1px solid #222;
                flex-shrink: 0;
            }
            #fg-tooltip {
                display: none;
                position: fixed;
                background: #222244;
                border: 1px solid #555;
                padding: 6px 10px;
                border-radius: 4px;
                font-size: 0.78em;
                pointer-events: none;
                z-index: 200;
                max-width: 600px;
                white-space: nowrap;
                color: #e0e0e0;
            }
        </style>
    </head>
    <body>
        <div id="drop-zone">
            <div>
                <div style="font-size: 2em; margin-bottom: 12px">ðŸ“Š</div>
                <div>
                    Drop a <code>.bin</code> trace file here or click to open
                </div>
                <div style="font-size: 0.8em; margin-top: 8px; color: #666">
                    Expects TOKIOTRC binary format
                </div>
            </div>
            <input type="file" id="file-input" accept=".bin" />
        </div>

        <div id="viewer">
            <div id="toolbar">
                <span class="filename" id="tb-filename"></span>
                <span class="stats" id="tb-stats"></span>
                <span style="flex: 1"></span>
                <select id="poi-filter">
                    <option value="sched">Kernel Scheduling Delays</option>
                    <option value="long-poll">Long Polls (>1ms)</option>
                    <option value="cpu-sampled">Polls with CPU Samples</option>
                    <option value="wake-delay">Wakeâ†’Poll Delays (>100Âµs)</option>
                </select>
                <label style="display:flex;align-items:center;gap:4px;font-size:0.85em;cursor:pointer">
                    <input type="checkbox" id="sort-by-worst" style="cursor:pointer">
                    Worst first
                </label>
                <button id="btn-prev-poi">â—€ Prev</button>
                <button id="btn-next-poi">Next â–¶</button>
                <span id="poi-counter" style="font-size:0.85em;color:#888"></span>
                <span style="width:1px;height:20px;background:#444;margin:0 8px"></span>
                <button id="btn-sched-panel" style="background:#3a1a1a;border-color:#ff4444;color:#ff8a65">âš  Blocking Calls</button>
                <button id="btn-zoom-in">Zoom +</button>
                <button id="btn-zoom-out">Zoom âˆ’</button>
                <button id="btn-fit">Fit All</button>
                <button id="btn-reset">New File</button>
            </div>
            <div id="main-area">
                <div id="selection-overlay"></div>
                <canvas id="crosshair-overlay" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10"></canvas>
                <div id="timeline-header">
                    <canvas id="timeline-canvas"></canvas>
                </div>
                <div id="lanes-container" id="lanes"></div>
                <div id="task-detail">
                    <span class="chart-label" id="task-detail-label">Task Detail</span>
                    <span id="task-detail-status" style="position:absolute;top:4px;right:12px;font-size:0.75em;color:#aaa;z-index:2"></span>
                    <canvas id="task-detail-canvas"></canvas>
                </div>
                <div id="queue-chart">
                    <span class="chart-label"
                        >Queue Depth (global=blue, local max=orange)</span
                    >
                    <canvas id="queue-canvas"></canvas>
                </div>
                <div id="flamegraph-panel">
                    <div class="fg-header">
                        <span class="fg-title" id="fg-title">Flamegraph</span>
                        <span class="fg-stats" id="fg-stats"></span>
                        <select id="fg-spawn-filter" style="background:#2a2a4a;border:1px solid #444;color:#ccc;padding:3px 6px;border-radius:4px;font-size:0.9em;max-width:350px"></select>
                        <span class="fg-close" id="fg-close">âœ• Close (Esc)</span>
                    </div>
                    <div style="flex:1;overflow-y:auto;display:flex;flex-direction:column">
                        <div class="fg-section-label" id="fg-worker-label">Worker threads</div>
                        <canvas id="fg-canvas-worker"></canvas>
                        <div class="fg-section-label" id="fg-offworker-label">Off-worker (sampler thread)</div>
                        <canvas id="fg-canvas-offworker"></canvas>
                    </div>
                </div>
                <div id="sched-panel" style="display:none;position:absolute;top:0;left:0;right:0;bottom:0;background:#1a1a2e;z-index:50;flex-direction:column">
                    <div style="display:flex;align-items:center;gap:12px;padding:6px 12px;background:#16213e;border-bottom:1px solid #333;font-size:0.8em;flex-shrink:0">
                        <span style="color:#ff4444;font-weight:600" id="sched-panel-title">âš  Scheduling Events</span>
                        <span style="color:#888" id="sched-panel-stats"></span>
                        <select id="sched-group-by" style="background:#2a2a4a;border:1px solid #444;color:#ccc;padding:3px 6px;border-radius:4px;font-size:0.9em">
                            <option value="leaf">Group by blocking call</option>
                            <option value="full">Group by full stack</option>
                        </select>
                        <span style="flex:1"></span>
                        <span id="sched-panel-close" style="cursor:pointer;color:#888;padding:0 4px">âœ• Close (Esc)</span>
                    </div>
                    <div id="sched-panel-body" style="flex:1;overflow-y:auto;padding:8px 12px;font-family:monospace;font-size:0.82em;line-height:1.5"></div>
                </div>
            </div>
        </div>

        <div id="tooltip"></div>
        <div id="fg-tooltip"></div>
        <div id="stack-popup" style="display:none;position:fixed;background:#1a1a2e;border:1px solid #6c63ff;border-radius:8px;padding:12px 16px;z-index:200;max-width:800px;max-height:600px;overflow-y:auto;font-size:0.8em;line-height:1.6;box-shadow:0 4px 20px rgba(0,0,0,0.5)">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                <span id="stack-popup-title" style="color:#6c63ff;font-weight:600"></span>
                <span id="stack-popup-close" style="cursor:pointer;color:#888;font-size:1.2em;padding:0 4px">&times;</span>
            </div>
            <div id="stack-popup-body" style="font-family:monospace;font-size:0.9em"></div>
        </div>

        <script>
            // â”€â”€ Binary Parser (v11 format) â”€â”€
            // Wire codes:
            //   0: PollStart        â†’ code(1) + ts(4) + worker(1) + local_q(1) + task_id(4) + spawn_loc_id(2) = 13 bytes
            //   1: PollEnd          â†’ code(1) + ts(4) + worker(1)                                              = 6 bytes
            //   2: WorkerPark       â†’ code(1) + ts(4) + worker(1) + local_q(1) + cpu_us(4)                    = 11 bytes
            //   3: WorkerUnpark     â†’ code(1) + ts(4) + worker(1) + local_q(1) + cpu_us(4) + sched_wait_us(4) = 15 bytes
            //   4: QueueSample      â†’ code(1) + ts(4) + global_q(1)                                           = 6 bytes
            //   5: SpawnLocationDef â†’ code(1) + spawn_loc_id(2) + string_len(2) + string_bytes(N)
            //   6: TaskSpawn        â†’ code(1) + task_id(4) + spawn_loc_id(2)                                  = 7 bytes
            //   7: CpuSample        â†’ code(1) + ts(4) + worker(1) + num_frames(1) + frames(N*8)
            //   8: CallframeDef     â†’ code(1) + address(8) + string_len(2) + string_bytes(N)
            //   9: WakeEvent        â†’ code(1) + ts(4) + waker_task_id(4) + woken_task_id(4) + target_worker(1) = 14 bytes
            const MAX_EVENTS = 2_000_000; // cap parsed events to keep UI responsive

            function parseTrace(buffer) {
                const view = new DataView(buffer);
                let off = 0;
                const magic = String.fromCharCode(
                    ...new Uint8Array(buffer, 0, 8),
                );
                off += 8;
                const version = view.getUint32(off, true);
                off += 4;
                if (magic !== "TOKIOTRC")
                    throw new Error("Not a TOKIOTRC file (got: " + magic + ")");
                if (version !== 8) {
                    console.warn(`Expected version 8-11, got ${version}. Some data may be missing.`);
                }
                const hasCpuTime = version >= 5;
                const hasSchedWait = version >= 6;
                const hasTaskTracking = version >= 7;

                const events = [];
                const spawnLocations = new Map(); // SpawnLocationId (number) â†’ string
                const taskSpawnLocs = new Map();  // taskId (number) â†’ SpawnLocationId (number)
                const callframeSymbols = new Map(); // address (bigint as string) â†’ symbol name
                const cpuSamples = []; // {timestamp, workerId, callchain: [addr strings]}
                const decoder = new TextDecoder();
                while (off < buffer.byteLength && events.length < MAX_EVENTS) {
                    if (off + 1 > buffer.byteLength) break;
                    const wireCode = view.getUint8(off);
                    off += 1;

                    // SpawnLocationDef and TaskSpawn have no timestamp â€” handle before reading ts
                    if (wireCode === 5) {
                        if (off + 4 > buffer.byteLength) break;
                        const spawnLocId = view.getUint16(off, true); off += 2;
                        const strLen = view.getUint16(off, true); off += 2;
                        if (off + strLen > buffer.byteLength) break;
                        spawnLocations.set(spawnLocId, decoder.decode(new Uint8Array(buffer, off, strLen)));
                        off += strLen;
                        continue;
                    }
                    if (wireCode === 6) {
                        if (off + 6 > buffer.byteLength) break;
                        const taskId = view.getUint32(off, true); off += 4;
                        const spawnLocId = view.getUint16(off, true); off += 2;
                        taskSpawnLocs.set(taskId, spawnLocId);
                        continue;
                    }
                    if (wireCode === 8) {
                        // CallframeDef: address(8) + string_len(2) + string_bytes(N)
                        if (off + 10 > buffer.byteLength) break;
                        const lo = view.getUint32(off, true);
                        const hi = view.getUint32(off + 4, true);
                        off += 8;
                        const addrKey = "0x" + (hi * 0x100000000 + lo).toString(16);
                        const strLen = view.getUint16(off, true); off += 2;
                        if (off + strLen > buffer.byteLength) break;
                        callframeSymbols.set(addrKey, decoder.decode(new Uint8Array(buffer, off, strLen)));
                        off += strLen;
                        continue;
                    }

                    if (wireCode === 7) {
                        // CpuSample: timestamp_us(4) + worker_id(1) + source(1) + num_frames(1) + frames(N*8)
                        if (off + 7 > buffer.byteLength) break;
                        const tsUs = view.getUint32(off, true); off += 4;
                        const wid = view.getUint8(off); off += 1;
                        const src = view.getUint8(off); off += 1; // 0=CpuProfile, 1=SchedEvent
                        const nf = view.getUint8(off); off += 1;
                        if (off + nf * 8 > buffer.byteLength) break;
                        const chain = [];
                        for (let i = 0; i < nf; i++) {
                            const lo = view.getUint32(off, true);
                            const hi = view.getUint32(off + 4, true);
                            off += 8;
                            chain.push("0x" + (hi * 0x100000000 + lo).toString(16));
                        }
                        cpuSamples.push({ timestamp: tsUs * 1000, workerId: wid, source: src, callchain: chain });
                        continue;
                    }

                    if (wireCode === 9) {
                        // WakeEvent: ts(4) + waker_task_id(4) + woken_task_id(4) + target_worker(1) = 13 after code
                        if (off + 13 > buffer.byteLength) break;
                        const timestampUs = view.getUint32(off, true); off += 4;
                        const wakerTaskId = view.getUint32(off, true); off += 4;
                        const wokenTaskId = view.getUint32(off, true); off += 4;
                        const targetWorker = view.getUint8(off); off += 1;
                        events.push({
                            eventType: 9, // WakeEvent
                            timestamp: timestampUs * 1000,
                            workerId: targetWorker,
                            wakerTaskId,
                            wokenTaskId,
                            targetWorker,
                            globalQueue: 0, localQueue: 0, cpuTime: 0, schedWait: 0,
                            taskId: 0, spawnLocId: 0, spawnLoc: null,
                        });
                        continue;
                    }

                    if (wireCode > 9) break; // unknown code

                    // All regular codes have a 4-byte timestamp next
                    if (off + 4 > buffer.byteLength) break;
                    const timestampUs = view.getUint32(off, true);
                    off += 4;
                    const timestamp = timestampUs * 1000;

                    let eventType,
                        workerId = 0,
                        globalQueue = 0,
                        localQueue = 0,
                        cpuTime = 0,
                        schedWait = 0,
                        taskId = 0,
                        spawnLocId = 0;
                    switch (wireCode) {
                        case 0: // PollStart
                            if (hasTaskTracking) {
                                // v8: worker(1) + lq(1) + task_id(4) + spawn_loc_id(2) = 8
                                if (off + 8 > buffer.byteLength) break;
                                eventType = 0;
                                workerId = view.getUint8(off); off += 1;
                                localQueue = view.getUint8(off); off += 1;
                                taskId = view.getUint32(off, true); off += 4;
                                spawnLocId = view.getUint16(off, true); off += 2;
                            } else {
                                if (off + 1 > buffer.byteLength) break;
                                eventType = 0;
                                workerId = view.getUint8(off); off += 1;
                            }
                            break;
                        case 1: // PollEnd
                            if (off + 1 > buffer.byteLength) break;
                            eventType = 1;
                            workerId = view.getUint8(off); off += 1;
                            break;
                        case 2: { // WorkerPark
                            const need = hasCpuTime ? 6 : 2;
                            if (off + need > buffer.byteLength) break;
                            eventType = 2;
                            workerId = view.getUint8(off); off += 1;
                            localQueue = view.getUint8(off); off += 1;
                            if (hasCpuTime) {
                                cpuTime = view.getUint32(off, true) * 1000; off += 4;
                            }
                            break;
                        }
                        case 3: { // WorkerUnpark
                            const need = hasCpuTime ? (hasSchedWait ? 10 : 6) : 2;
                            if (off + need > buffer.byteLength) break;
                            eventType = 3;
                            workerId = view.getUint8(off); off += 1;
                            localQueue = view.getUint8(off); off += 1;
                            if (hasCpuTime) {
                                cpuTime = view.getUint32(off, true) * 1000; off += 4;
                            }
                            if (hasSchedWait) {
                                schedWait = view.getUint32(off, true); off += 4;
                            }
                            break;
                        }
                        case 4: // QueueSample
                            if (off + 1 > buffer.byteLength) break;
                            eventType = 4;
                            globalQueue = view.getUint8(off); off += 1;
                            break;
                    }
                    // Also build taskSpawnLocs from PollStart (covers tasks without TaskSpawn events)
                    if (eventType === 0 && taskId && spawnLocId && !taskSpawnLocs.has(taskId)) {
                        taskSpawnLocs.set(taskId, spawnLocId);
                    }
                    events.push({
                        eventType, timestamp, workerId,
                        globalQueue, localQueue, cpuTime, schedWait,
                        taskId, spawnLocId,
                        spawnLoc: spawnLocations.get(spawnLocId) ?? null,
                    });
                }
                return { magic, version, events, truncated: events.length >= MAX_EVENTS, hasCpuTime, hasSchedWait, hasTaskTracking, spawnLocations, taskSpawnLocs, cpuSamples, callframeSymbols };
            }

            // â”€â”€ Event type helpers â”€â”€
            const ET = {
                PollStart: 0,
                PollEnd: 1,
                WorkerPark: 2,
                WorkerUnpark: 3,
                QueueSample: 4,
                WakeEvent: 9,
            };
            const ET_NAMES = [
                "PollStart",
                "PollEnd",
                "WorkerPark",
                "WorkerUnpark",
                "QueueSample",
            ];
            const ET_COLORS = { poll: "#4fc3f7", park: "#ff8a65" };

            // Duration-based poll coloring: short=dim, long=hot
            function pollColor(startNs, endNs) {
                const durUs = (endNs - startNs) / 1e3;
                if (durUs > 1000) return "#ff4444"; // >1ms: red
                if (durUs > 100)  return "#ff8a65"; // >100Âµs: orange
                if (durUs > 10)   return "#4fc3f7"; // >10Âµs: bright blue
                return "#2a5a7a";                    // â‰¤10Âµs: dim blue
            }

            function pollColorDim(startNs, endNs) {
                const durUs = (endNs - startNs) / 1e3;
                if (durUs > 1000) return "#803030"; // >1ms: muted red
                if (durUs > 100)  return "#805540"; // >100Âµs: muted orange
                if (durUs > 10)   return "#2a5a7a"; // >10Âµs: dim blue
                return "#1e3040";                    // â‰¤10Âµs: very dim
            }

            // â”€â”€ State â”€â”€
            let trace = null;
            let workerIds = [];
            let minTs = 0,
                maxTs = 0,
                durationNs = 0;
            // View window in nanoseconds
            let viewStart = 0,
                viewEnd = 0;
            // Precomputed spans per worker: { polls: [{start,end}], parks: [{start,end}] }
            let workerSpans = {};
            // Queue depth samples sorted by time
            let queueSamples = [];
            // Per-worker local queue samples
            let workerQueueSamples = {};
            let maxLocalQueue = 1;
            // Points of interest for navigation
            let pointsOfInterest = [];
            let currentPoiIndex = -1;
            // Task selection state
            let selectedTaskId = null;
            // Hovered waker task in task detail panel
            let hoveredWakerTaskId = null;
            // Stored wake hit regions for task detail mouseover: [{x1, x2, y1, y2, wakerTaskId}]
            let taskDetailWakeRegions = [];
            // Wake events indexed by woken task ID
            let wakesByTask = {}; // taskId â†’ [{timestamp, wakerTaskId, targetWorker}]
            // Wake events indexed by target worker
            let wakesByWorker = {}; // workerId â†’ [{timestamp, wakerTaskId, wokenTaskId}]
            // Scheduling delays: wake â†’ next poll for same task
            let schedDelays = []; // [{wakeTime, pollTime, delay, taskId, wakerTaskId, worker}]

            const LABEL_W = 100;
            const LANE_H = 60;

            // â”€â”€ DOM refs â”€â”€
            const dropZone = document.getElementById("drop-zone");
            const fileInput = document.getElementById("file-input");
            const viewer = document.getElementById("viewer");
            const tooltip = document.getElementById("tooltip");
            const timelineCanvas = document.getElementById("timeline-canvas");
            const queueCanvas = document.getElementById("queue-canvas");
            const lanesContainer = document.getElementById("lanes-container");

            // â”€â”€ File loading â”€â”€
            dropZone.addEventListener("click", () => fileInput.click());
            dropZone.addEventListener("dragover", (e) => {
                e.preventDefault();
                dropZone.classList.add("dragover");
            });
            dropZone.addEventListener("dragleave", () =>
                dropZone.classList.remove("dragover"),
            );
            dropZone.addEventListener("drop", (e) => {
                e.preventDefault();
                dropZone.classList.remove("dragover");
                loadFile(e.dataTransfer.files[0]);
            });
            fileInput.addEventListener("change", (e) => {
                if (e.target.files[0]) loadFile(e.target.files[0]);
            });
            document
                .getElementById("btn-reset")
                .addEventListener("click", () => {
                    viewer.style.display = "none";
                    dropZone.style.display = "flex";
                });

            function loadFile(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        trace = parseTrace(e.target.result);
                        processTrace();
                        showViewer(file.name);
                    } catch (err) {
                        alert("Error: " + err.message);
                    }
                };
                // Only read first 20MB â€” parser caps at MAX_EVENTS anyway
                const maxBytes = 20 * 1024 * 1024;
                const blob = file.size > maxBytes ? file.slice(0, maxBytes) : file;
                reader.readAsArrayBuffer(blob);
            }

            function processTrace() {
                const evts = trace.events;
                if (!evts.length) {
                    alert("No events in trace");
                    return;
                }

                const wSet = new Set();
                evts.forEach((e) => {
                    if (e.eventType !== ET.QueueSample && e.eventType !== ET.WakeEvent) wSet.add(e.workerId);
                });
                workerIds = [...wSet].sort((a, b) => a - b);

                minTs = evts[0].timestamp;
                maxTs = evts[evts.length - 1].timestamp;
                // Scan for true min/max in case events aren't sorted
                for (const e of evts) {
                    if (e.timestamp < minTs) minTs = e.timestamp;
                    if (e.timestamp > maxTs) maxTs = e.timestamp;
                }
                durationNs = maxTs - minTs || 1;
                viewStart = minTs;
                viewEnd = maxTs;

                // Build spans
                workerSpans = {};
                const openPoll = {},
                    openPark = {},
                    openUnpark = {}; // track {timestamp, cpuTime} at unpark
                const openPollMeta = {}; // track {taskId, spawnLocId} at PollStart
                for (const w of workerIds) {
                    workerSpans[w] = { polls: [], parks: [], actives: [] };
                }

                // Group events by worker and sort per-worker by timestamp
                // (events arrive in flush order, not global timestamp order)
                const perWorker = {};
                const globalEvts = []; // QueueSample etc
                for (const e of evts) {
                    if (e.eventType === ET.QueueSample || e.eventType === ET.WakeEvent) {
                        globalEvts.push(e);
                    } else {
                        (perWorker[e.workerId] ??= []).push(e);
                    }
                }
                for (const wEvents of Object.values(perWorker)) {
                    wEvents.sort((a, b) => a.timestamp - b.timestamp);
                }

                for (const [w, wEvents] of Object.entries(perWorker)) {
                    for (const e of wEvents) {
                        if (e.eventType === ET.PollStart) {
                            openPoll[w] = e.timestamp;
                            openPollMeta[w] = { taskId: e.taskId, spawnLocId: e.spawnLocId, spawnLoc: e.spawnLoc };
                        } else if (e.eventType === ET.PollEnd) {
                            if (openPoll[w] != null) {
                                const meta = openPollMeta[w] || { taskId: 0, spawnLocId: 0, spawnLoc: null };
                                workerSpans[w].polls.push({
                                    start: openPoll[w],
                                    end: e.timestamp,
                                    taskId: meta.taskId,
                                    spawnLocId: meta.spawnLocId,
                                    spawnLoc: meta.spawnLoc,
                                });
                                openPoll[w] = null;
                            }
                        } else if (e.eventType === ET.WorkerPark) {
                            openPark[w] = e.timestamp;
                            // Close active period
                            if (openUnpark[w] != null) {
                                const wallDelta = e.timestamp - openUnpark[w].timestamp;
                                const cpuDelta = e.cpuTime - openUnpark[w].cpuTime;
                                const ratio = wallDelta > 0 ? Math.min(cpuDelta / wallDelta, 1.0) : 1.0;
                                workerSpans[w].actives.push({
                                    start: openUnpark[w].timestamp,
                                    end: e.timestamp,
                                    ratio,
                                });
                                openUnpark[w] = null;
                            }
                        } else if (e.eventType === ET.WorkerUnpark) {
                            if (openPark[w] != null) {
                                workerSpans[w].parks.push({
                                    start: openPark[w],
                                    end: e.timestamp,
                                    schedWait: e.schedWait,
                                });
                                openPark[w] = null;
                            }
                            openUnpark[w] = { timestamp: e.timestamp, cpuTime: e.cpuTime };
                        }
                    }
                }
                // Close any open spans at trace end
                for (const w of workerIds) {
                    if (openPoll[w] != null)
                        workerSpans[w].polls.push({
                            start: openPoll[w],
                            end: maxTs,
                        });
                    if (openPark[w] != null)
                        workerSpans[w].parks.push({
                            start: openPark[w],
                            end: maxTs,
                        });
                }

                // Debug: log active period stats
                for (const w of workerIds) {
                    const a = workerSpans[w].actives;
                    console.log(`Worker ${w}: ${a.length} active periods` +
                        (a.length > 0 ? `, first ratio=${a[0].ratio.toFixed(3)}` : ''));
                }

                // Global queue samples (from QueueSample events only)
                queueSamples = evts
                    .filter((e) => e.eventType === ET.QueueSample)
                    .map((e) => ({ t: e.timestamp, global: e.globalQueue }));
                console.log(`Found ${queueSamples.length} global queue samples`);

                // Attach CPU samples to poll spans they fall within
                if (trace.cpuSamples.length > 0) {
                    for (const sample of trace.cpuSamples) {
                        const spans = workerSpans[sample.workerId];
                        if (!spans) { sample.spawnLoc = null; continue; }
                        let found = false;
                        for (const poll of spans.polls) {
                            if (sample.timestamp >= poll.start && sample.timestamp <= poll.end) {
                                if (sample.source === 1) {
                                    // SchedEvent â€” kernel descheduled this worker during a poll (blocking!)
                                    (poll.schedSamples ??= []).push(sample);
                                } else {
                                    (poll.cpuSamples ??= []).push(sample);
                                }
                                sample.spawnLoc = poll.spawnLoc;
                                found = true;
                                break;
                            }
                        }
                        if (!found) sample.spawnLoc = null;
                    }
                    let pollsWithSamples = 0;
                    let pollsWithSched = 0;
                    for (const w of workerIds) {
                        for (const p of workerSpans[w].polls) {
                            if (p.cpuSamples) pollsWithSamples++;
                            if (p.schedSamples) pollsWithSched++;
                        }
                    }
                    console.log(`CPU samples: ${trace.cpuSamples.length}, polls with cpu samples: ${pollsWithSamples}, polls with sched events: ${pollsWithSched}`);
                }

                // Per-worker local queue samples (from events that have local_queue)
                workerQueueSamples = {};
                maxLocalQueue = 1;
                for (const w of workerIds) {
                    workerQueueSamples[w] = [];
                }
                for (const [w, wEvents] of Object.entries(perWorker)) {
                    for (const e of wEvents) {
                        if (e.eventType === ET.PollStart || e.eventType === ET.WorkerPark || e.eventType === ET.WorkerUnpark) {
                            workerQueueSamples[w] ??= [];
                            workerQueueSamples[w].push({
                                t: e.timestamp,
                                local: e.localQueue,
                            });
                            if (e.localQueue > maxLocalQueue)
                                maxLocalQueue = e.localQueue;
                        }
                    }
                }

                // Index wake events by woken task ID
                wakesByTask = {};
                for (const e of evts) {
                    if (e.eventType === ET.WakeEvent) {
                        (wakesByTask[e.wokenTaskId] ??= []).push({
                            timestamp: e.timestamp,
                            wakerTaskId: e.wakerTaskId,
                            targetWorker: e.targetWorker,
                        });
                    }
                }
                for (const arr of Object.values(wakesByTask)) {
                    arr.sort((a, b) => a.timestamp - b.timestamp);
                }

                // Index wake events by target worker
                wakesByWorker = {};
                for (const e of evts) {
                    if (e.eventType === ET.WakeEvent) {
                        (wakesByWorker[e.targetWorker] ??= []).push({
                            timestamp: e.timestamp,
                            wakerTaskId: e.wakerTaskId,
                            wokenTaskId: e.wokenTaskId,
                        });
                    }
                }
                for (const arr of Object.values(wakesByWorker)) {
                    arr.sort((a, b) => a.timestamp - b.timestamp);
                }

                // Compute scheduling delays: for each poll, find the most recent wake before it
                // Build task â†’ sorted polls index for mid-poll wake adjustment
                const pollsByTask = {};
                for (const w of workerIds) {
                    for (const s of workerSpans[w].polls) {
                        if (s.taskId) (pollsByTask[s.taskId] ??= []).push(s);
                    }
                }
                for (const arr of Object.values(pollsByTask)) {
                    arr.sort((a, b) => a.start - b.start);
                }

                schedDelays = [];
                for (const w of workerIds) {
                    for (const s of workerSpans[w].polls) {
                        if (!s.taskId) continue;
                        const wakes = wakesByTask[s.taskId];
                        if (!wakes || !wakes.length) continue;
                        // Binary search for last wake <= s.start
                        let lo = 0, hi = wakes.length - 1, best = -1;
                        while (lo <= hi) {
                            const mid = (lo + hi) >> 1;
                            if (wakes[mid].timestamp <= s.start) { best = mid; lo = mid + 1; }
                            else hi = mid - 1;
                        }
                        if (best >= 0) {
                            const wake = wakes[best];
                            // If wake arrived during an earlier poll of this task, effective wait starts at that poll's end
                            let effectiveWake = wake.timestamp;
                            const taskPolls = pollsByTask[s.taskId];
                            if (taskPolls) {
                                for (const p of taskPolls) {
                                    if (p.start >= s.start) break; // only earlier polls
                                    if (wake.timestamp >= p.start && wake.timestamp <= p.end) {
                                        effectiveWake = p.end;
                                        break;
                                    }
                                }
                            }
                            const delay = s.start - effectiveWake;
                            if (delay > 0 && delay < 1e9) { // sanity: < 1s
                                schedDelays.push({
                                    wakeTime: effectiveWake,
                                    pollTime: s.start,
                                    delay,
                                    taskId: s.taskId,
                                    wakerTaskId: wake.wakerTaskId,
                                    worker: w,
                                    poll: s,
                                });
                            }
                        }
                    }
                }
                schedDelays.sort((a, b) => a.wakeTime - b.wakeTime);
                console.log(`Found ${Object.keys(wakesByTask).length} tasks with wake events, ${schedDelays.length} scheduling delays`);
            }

            function showViewer(filename) {
                dropZone.style.display = "none";
                viewer.style.display = "flex";
                document.getElementById("tb-filename").textContent = filename;
                const durMs = durationNs / 1e6;
                const truncNote = trace.truncated ? " (truncated)" : "";
                document.getElementById("tb-stats").textContent =
                    `${trace.events.length.toLocaleString()} events Â· ${workerIds.length} workers Â· ${durMs.toFixed(1)}ms${truncNote}`;

                buildLanes();
                updatePointsOfInterest();
                // Show/hide sched panel button based on whether sched events exist
                let hasSchedEvents = false;
                for (const w of workerIds) {
                    for (const p of workerSpans[w].polls) {
                        if (p.schedSamples && p.schedSamples.length > 0) { hasSchedEvents = true; break; }
                    }
                    if (hasSchedEvents) break;
                }
                document.getElementById("btn-sched-panel").style.display = hasSchedEvents ? "" : "none";
                requestAnimationFrame(renderAll);
            }

            function updatePointsOfInterest() {
                const filterType = document.getElementById("poi-filter").value;
                pointsOfInterest = [];
                
                for (const w of workerIds) {
                    const spans = workerSpans[w];
                    
                    if (filterType === "sched") {
                        // Find parks with scheduling delays > 100Âµs
                        for (const s of spans.parks) {
                            if (trace.hasSchedWait && s.schedWait > 100) {
                                const schedWaitNs = s.schedWait * 1000;
                                const wakeupShouldBe = s.end - schedWaitNs;
                                pointsOfInterest.push({
                                    time: wakeupShouldBe,
                                    worker: w,
                                    type: "sched",
                                    value: s.schedWait,
                                    span: s
                                });
                            }
                        }
                    } else if (filterType === "long-poll") {
                        // Polls longer than 1ms
                        for (const s of spans.polls) {
                            const durMs = (s.end - s.start) / 1e6;
                            if (durMs > 1) {
                                pointsOfInterest.push({
                                    time: s.start,
                                    worker: w,
                                    type: "long-poll",
                                    value: durMs,
                                    span: s
                                });
                            }
                        }
                    } else if (filterType === "cpu-sampled") {
                        for (const s of spans.polls) {
                            const cpuCount = s.cpuSamples ? s.cpuSamples.length : 0;
                            const schedCount = s.schedSamples ? s.schedSamples.length : 0;
                            if (cpuCount + schedCount > 0) {
                                pointsOfInterest.push({
                                    time: s.start,
                                    worker: w,
                                    type: "cpu-sampled",
                                    value: cpuCount + schedCount,
                                    span: s
                                });
                            }
                        }
                    }
                }

                if (filterType === "wake-delay") {
                    // Wakeâ†’Poll scheduling delays > 100Âµs
                    for (const sd of schedDelays) {
                        const delayUs = sd.delay / 1000;
                        if (delayUs > 100) {
                            pointsOfInterest.push({
                                time: sd.wakeTime,
                                worker: sd.worker,
                                type: "wake-delay",
                                value: delayUs,
                                span: sd.poll,
                                schedDelay: sd,
                            });
                        }
                    }
                }
                
                // Sort by time or by worst value
                const sortByWorst = document.getElementById("sort-by-worst").checked;
                if (sortByWorst) {
                    pointsOfInterest.sort((a, b) => b.value - a.value);
                } else {
                    pointsOfInterest.sort((a, b) => a.time - b.time);
                }
                currentPoiIndex = -1;
                updatePoiCounter();
            }

            function updatePoiCounter() {
                const counter = document.getElementById("poi-counter");
                const prevBtn = document.getElementById("btn-prev-poi");
                const nextBtn = document.getElementById("btn-next-poi");
                
                if (pointsOfInterest.length === 0) {
                    counter.textContent = "None found";
                    prevBtn.disabled = true;
                    nextBtn.disabled = true;
                } else {
                    const idx = currentPoiIndex >= 0 ? currentPoiIndex + 1 : 0;
                    counter.textContent = `${idx}/${pointsOfInterest.length}`;
                    prevBtn.disabled = currentPoiIndex <= 0;
                    nextBtn.disabled = currentPoiIndex >= pointsOfInterest.length - 1;
                }
            }

            function jumpToPoi(index) {
                if (index < 0 || index >= pointsOfInterest.length) return;
                currentPoiIndex = index;
                const poi = pointsOfInterest[index];
                
                // Center view on this POI with appropriate zoom
                const spanDur = poi.span.end - poi.span.start;
                const viewDur = Math.max(spanDur * 5, 1e6); // Show 5x the span duration, min 1ms
                viewStart = Math.max(minTs, poi.time - viewDur * 0.3);
                viewEnd = Math.min(maxTs, viewStart + viewDur);

                // For wake-delay POIs, include the wake event in the view and select the task
                if (poi.schedDelay) {
                    const sd = poi.schedDelay;
                    const totalDur = sd.poll.end - sd.wakeTime;
                    const padded = Math.max(totalDur * 3, 1e6);
                    viewStart = Math.max(minTs, sd.wakeTime - padded * 0.2);
                    viewEnd = Math.min(maxTs, viewStart + padded);
                    selectedTaskId = sd.taskId;
                }
                
                // Scroll to worker lane
                const laneIdx = workerIds.indexOf(poi.worker);
                if (laneIdx >= 0) {
                    const scrollTop = laneIdx * LANE_H;
                    lanesContainer.scrollTop = scrollTop;
                }
                
                updatePoiCounter();
                renderAll();
            }

            // â”€â”€ Lane DOM â”€â”€
            let laneCanvases = {};
            function buildLanes() {
                lanesContainer.innerHTML = "";
                laneCanvases = {};
                for (const w of workerIds) {
                    const lane = document.createElement("div");
                    lane.className = "lane";
                    const label = document.createElement("div");
                    label.className = "lane-label";
                    label.textContent = `Worker ${w}`;
                    const content = document.createElement("div");
                    content.className = "lane-content";
                    const canvas = document.createElement("canvas");
                    canvas.id = `worker-${w}-canvas`;
                    content.appendChild(canvas);
                    lane.appendChild(label);
                    lane.appendChild(content);
                    lanesContainer.appendChild(lane);
                    laneCanvases[w] = canvas;
                }
            }

            // â”€â”€ Rendering â”€â”€
            let mouseNs = null; // Track mouse position for crosshair
            let queueChartRafId = null; // Throttle queue chart redraws
            function renderAll() {
                const rect = lanesContainer.getBoundingClientRect();
                const drawW = rect.width - LABEL_W;
                if (drawW <= 0) return;

                // Scrollbar width: difference between container and its usable content area
                const scrollbarW = lanesContainer.offsetWidth - lanesContainer.clientWidth;

                // First pass: calculate max visible queue across all workers
                window.visibleQueueRanges = {};
                let maxVisibleQ = 1;
                for (const w of workerIds) {
                    const samples = workerQueueSamples[w];
                    if (!samples || !samples.length) continue;
                    for (const s of samples) {
                        if (s.t >= viewStart && s.t <= viewEnd && s.local > maxVisibleQ) {
                            maxVisibleQ = s.local;
                        }
                    }
                }
                window.sharedVisibleMaxQ = maxVisibleQ;

                renderTimeline(drawW - scrollbarW);
                for (const w of workerIds) renderLane(w, drawW);
                renderTaskDetail(scrollbarW);
                renderQueueChart(drawW, scrollbarW);
            }

            function nsToX(ns, drawW) {
                return ((ns - viewStart) / (viewEnd - viewStart)) * drawW;
            }

            function renderTimeline(drawW) {
                const c = timelineCanvas;
                const parent = c.parentElement;
                const dpr = devicePixelRatio || 1;
                c.width = parent.clientWidth * dpr;
                c.height = 30 * dpr;
                c.style.width = parent.clientWidth + "px";
                c.style.height = "30px";
                const ctx = c.getContext("2d");
                ctx.scale(dpr, dpr);
                const w = parent.clientWidth;

                ctx.fillStyle = "#16213e";
                ctx.fillRect(0, 0, w, 30);

                const viewDur = viewEnd - viewStart;
                // Pick nice tick interval
                const targetTicks = Math.max(4, Math.floor(drawW / 100));
                const rawInterval = viewDur / targetTicks;
                const niceIntervals = [
                    1e3, 5e3, 1e4, 5e4, 1e5, 5e5, 1e6, 5e6, 1e7, 5e7, 1e8, 5e8,
                    1e9, 5e9, 1e10,
                ];
                let interval =
                    niceIntervals.find((i) => i >= rawInterval) || rawInterval;

                ctx.fillStyle = "#888";
                ctx.font = "10px monospace";
                ctx.textAlign = "center";
                ctx.strokeStyle = "#333";

                const firstTick = Math.ceil(viewStart / interval) * interval;
                for (let t = firstTick; t <= viewEnd; t += interval) {
                    const x = LABEL_W + nsToX(t, drawW);
                    ctx.beginPath();
                    ctx.moveTo(x, 20);
                    ctx.lineTo(x, 30);
                    ctx.stroke();
                    const relMs = (t - minTs) / 1e6;
                    let label;
                    if (relMs >= 1000) label = (relMs / 1000).toFixed(2) + "s";
                    else if (relMs >= 1) label = relMs.toFixed(2) + "ms";
                    else label = (relMs * 1000).toFixed(0) + "Âµs";
                    ctx.fillText(label, x, 16);
                }
            }

            function renderLane(workerId, drawW) {
                const c = laneCanvases[workerId];
                if (!c) {
                    console.error(`No canvas for worker ${workerId}`);
                    return;
                }
                const parent = c.parentElement;
                const dpr = devicePixelRatio || 1;
                const pw = parent.clientWidth,
                    ph = LANE_H;
                c.width = pw * dpr;
                c.height = ph * dpr;
                c.style.width = pw + "px";
                c.style.height = ph + "px";
                const ctx = c.getContext("2d");
                ctx.scale(dpr, dpr);

                const spans = workerSpans[workerId];

                // Background: active = dark, parked = distinct reddish-brown
                // First fill entire lane as "active" (dark)
                ctx.fillStyle = "#1a1e2a";
                ctx.fillRect(0, 0, pw, ph);

                // Color-code active periods by scheduling ratio (v5+ only)
                if (trace.hasCpuTime) {
                    for (const s of spans.actives) {
                        if (s.end < viewStart || s.start > viewEnd) continue;
                        const x1 = Math.max(0, nsToX(s.start, pw));
                        const x2 = Math.min(pw, nsToX(s.end, pw));
                        const w = Math.max(x2 - x1, 1);
                        if (s.ratio >= 0.95) {
                            ctx.fillStyle = "#1a2a1a"; // green tint â€” healthy
                        } else if (s.ratio >= 0.5) {
                            ctx.fillStyle = "#2a2a1a"; // yellow tint â€” some preemption
                        } else {
                            ctx.fillStyle = "#2a1a1a"; // red tint â€” heavily descheduled
                        }
                        ctx.fillRect(x1, 0, w, ph);
                    }
                }

                // Draw park spans â€” split into normal park (muted) and scheduling delay (bright red)
                for (const s of spans.parks) {
                    if (s.end < viewStart || s.start > viewEnd) continue;
                    const x1 = Math.max(0, nsToX(s.start, pw));
                    const x2 = Math.min(pw, nsToX(s.end, pw));
                    const w = Math.max(x2 - x1, 1);
                    
                    // If we have scheduling delay info, split the park visually
                    if (trace.hasSchedWait && s.schedWait > 0) {
                        const schedWaitNs = s.schedWait * 1000; // convert Âµs to ns
                        const wakeupShouldBe = s.end - schedWaitNs;
                        
                        // Normal park portion (before wakeup should have happened)
                        if (wakeupShouldBe > s.start) {
                            const xSplit = Math.min(pw, nsToX(wakeupShouldBe, pw));
                            const normalW = Math.max(xSplit - x1, 0);
                            if (normalW > 0) {
                                ctx.fillStyle = "#2a1520";
                                ctx.fillRect(x1, 0, normalW, ph);
                                ctx.fillStyle = "#cc5533";
                                ctx.fillRect(x1, 0, normalW, 4);
                            }
                            
                            // Scheduling delay portion (bright red)
                            const delayW = Math.max(x2 - xSplit, 0);
                            if (delayW > 0) {
                                ctx.fillStyle = "#ff0000";
                                ctx.fillRect(xSplit, 0, delayW, ph);
                            }
                        } else {
                            // Entire park is scheduling delay
                            ctx.fillStyle = "#ff0000";
                            ctx.fillRect(x1, 0, w, ph);
                        }
                    } else {
                        // No scheduling delay info, draw as normal park
                        ctx.fillStyle = "#2a1520";
                        ctx.fillRect(x1, 0, w, ph);
                        ctx.fillStyle = "#cc5533";
                        ctx.fillRect(x1, 0, w, 4);
                    }
                }

                // Draw poll spans (solid blue bars, center band)
                // When a task is selected, draw in two passes: dim first, selected on top
                const bandTop = 10,
                    bandH = 20;
                const poiSpan = (currentPoiIndex >= 0) ? pointsOfInterest[currentPoiIndex].span : null;
                if (selectedTaskId) {
                    for (const s of spans.polls) {
                        if (s.end < viewStart || s.start > viewEnd || s.taskId === selectedTaskId) continue;
                        const x1 = Math.max(0, nsToX(s.start, pw));
                        const x2 = Math.min(pw, nsToX(s.end, pw));
                        ctx.fillStyle = pollColorDim(s.start, s.end);
                        ctx.fillRect(x1, bandTop, Math.max(x2 - x1, 1), bandH);
                    }
                    ctx.fillStyle = "#ffeb3b";
                    for (const s of spans.polls) {
                        if (s.end < viewStart || s.start > viewEnd || s.taskId !== selectedTaskId) continue;
                        const x1 = Math.max(0, nsToX(s.start, pw));
                        const x2 = Math.min(pw, nsToX(s.end, pw));
                        ctx.fillRect(x1, bandTop, Math.max(x2 - x1, 1), bandH);
                    }
                } else {
                    for (const s of spans.polls) {
                        if (s.end < viewStart || s.start > viewEnd) continue;
                        const x1 = Math.max(0, nsToX(s.start, pw));
                        const x2 = Math.min(pw, nsToX(s.end, pw));
                        ctx.fillStyle = pollColor(s.start, s.end);
                        ctx.fillRect(x1, bandTop, Math.max(x2 - x1, 1), bandH);
                    }
                }
                // Highlight current POI span
                if (poiSpan) {
                    for (const s of spans.polls) {
                        if (s !== poiSpan || s.end < viewStart || s.start > viewEnd) continue;
                        const x1 = Math.max(0, nsToX(s.start, pw));
                        const x2 = Math.min(pw, nsToX(s.end, pw));
                        const w = Math.max(x2 - x1, 5);
                        ctx.fillStyle = "#ff4444";
                        ctx.fillRect(x1, bandTop, w, bandH);
                        ctx.strokeStyle = "#ffffff";
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x1, bandTop, w, bandH);
                    }
                }

                // Mark polls that have CPU samples with an orange top stripe
                ctx.fillStyle = "#ff8c00";
                for (const s of spans.polls) {
                    if (!s.cpuSamples || s.end < viewStart || s.start > viewEnd) continue;
                    const x1 = Math.max(0, nsToX(s.start, pw));
                    const x2 = Math.min(pw, nsToX(s.end, pw));
                    const w = Math.max(x2 - x1, 3);
                    ctx.fillRect(x1, bandTop, w, 3);
                }

                // Mark polls that have sched events with red triangles below the poll band
                for (const s of spans.polls) {
                    if (!s.schedSamples || s.end < viewStart || s.start > viewEnd) continue;
                    for (const sample of s.schedSamples) {
                        if (sample.timestamp < viewStart || sample.timestamp > viewEnd) continue;
                        const x = nsToX(sample.timestamp, pw);
                        ctx.fillStyle = "#ff2222";
                        ctx.beginPath();
                        ctx.moveTo(x, bandTop + bandH + 1);
                        ctx.lineTo(x - 3, bandTop + bandH + 7);
                        ctx.lineTo(x + 3, bandTop + bandH + 7);
                        ctx.closePath();
                        ctx.fill();
                    }
                }

                // Highlight hovered waker task's polls (orange)
                if (hoveredWakerTaskId) {
                    ctx.fillStyle = "#ff8a65";
                    for (const s of spans.polls) {
                        if (s.end < viewStart || s.start > viewEnd || s.taskId !== hoveredWakerTaskId) continue;
                        const x1 = Math.max(0, nsToX(s.start, pw));
                        const x2 = Math.min(pw, nsToX(s.end, pw));
                        ctx.fillRect(x1, bandTop, Math.max(x2 - x1, 2), bandH);
                    }
                }

                // Draw wake event markers on this worker lane (only when a task is selected)
                if (selectedTaskId) {
                    const wakes = wakesByWorker[workerId];
                    if (wakes && wakes.length) {
                        ctx.fillStyle = "#66bb6a";
                        for (const w of wakes) {
                            if (w.timestamp < viewStart || w.timestamp > viewEnd) continue;
                            if (w.wokenTaskId !== selectedTaskId) continue;
                            const x = nsToX(w.timestamp, pw);
                            // Small downward triangle at top of lane
                            ctx.beginPath();
                            ctx.moveTo(x, 2);
                            ctx.lineTo(x - 3, 8);
                            ctx.lineTo(x + 3, 8);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }
                }

                // Overlay local queue depth as a step chart in the bottom portion
                const samples = workerQueueSamples[workerId];
                if (samples && samples.length) {
                    // Find visible range with one sample before and after for continuity
                    let iStart = 0,
                        iEnd = samples.length - 1;
                    // Find first sample >= viewStart
                    for (let i = 0; i < samples.length; i++) {
                        if (samples[i].t >= viewStart) {
                            iStart = Math.max(0, i - 1);
                            break;
                        }
                    }
                    // Find last sample <= viewEnd
                    for (let i = samples.length - 1; i >= 0; i--) {
                        if (samples[i].t <= viewEnd) {
                            iEnd = Math.min(samples.length - 1, i + 1);
                            break;
                        }
                    }

                    // Store visible range for later max calculation
                    if (!window.visibleQueueRanges) window.visibleQueueRanges = {};
                    window.visibleQueueRanges[workerId] = { iStart, iEnd };

                    const qTop = 34,
                        qH = ph - 38;

                    // Use shared max (calculated in renderAllLanes)
                    const laneMaxQ = window.sharedVisibleMaxQ || 1;

                    // Draw scale label
                    ctx.fillStyle = "#666";
                    ctx.font = "8px monospace";
                    ctx.textAlign = "left";
                    ctx.fillText("q:" + laneMaxQ, 2, qTop + 8);

                    // Draw step chart - stroke only, no fill to avoid artifacts
                    ctx.beginPath();
                    let started = false;
                    let lastY = qTop + qH;
                    for (let i = iStart; i <= iEnd; i++) {
                        const x = Math.max(0, Math.min(pw, nsToX(samples[i].t, pw)));
                        const y = qTop + qH - (samples[i].local / laneMaxQ) * qH;
                        
                        if (!started) {
                            ctx.moveTo(x, y);
                            started = true;
                        } else {
                            ctx.lineTo(x, lastY);
                            ctx.lineTo(x, y);
                        }
                        lastY = y;
                    }
                    ctx.lineTo(pw, lastY);
                    const colors = ["rgba(255,200,50,0.8)", "rgba(50,255,200,0.8)", "rgba(255,50,200,0.8)", "rgba(200,50,255,0.8)"];
                    ctx.strokeStyle = colors[workerId % colors.length];
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }

                // Separator line between poll band and queue area
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(0, 33);
                ctx.lineTo(pw, 33);
                ctx.stroke();
            }

            // Hit regions for task detail tooltip: [{x1, x2, y1, y2, type, detail}]
            let taskDetailHitRegions = [];

            function renderTaskDetail(scrollbarW) {
                const panel = document.getElementById("task-detail");
                const c = document.getElementById("task-detail-canvas");
                if (!selectedTaskId) {
                    panel.style.display = "none";
                    return;
                }

                // Collect all polls for this task across all workers, sorted by start time
                const polls = [];
                for (const w of workerIds) {
                    for (const s of workerSpans[w].polls) {
                        if (s.taskId === selectedTaskId) polls.push(s);
                    }
                }
                polls.sort((a, b) => a.start - b.start);
                if (polls.length < 1) { panel.style.display = "none"; return; }

                // Get wake events for this task
                const wakes = wakesByTask[selectedTaskId] || [];

                panel.style.display = "block";
                const loc = trace.spawnLocations.get(polls[0].spawnLocId);
                const wakeCount = wakes.length;
                document.getElementById("task-detail-label").textContent =
                    `Task 0x${selectedTaskId.toString(16)}${loc ? " â€” " + loc : ""} Â· ${polls.length} polls Â· ${wakeCount} wakes`;

                const parent = c.parentElement;
                const dpr = devicePixelRatio || 1;
                const pw = parent.clientWidth, ph = parent.clientHeight;
                c.width = pw * dpr;
                c.height = ph * dpr;
                c.style.width = pw + "px";
                c.style.height = ph + "px";
                const ctx = c.getContext("2d");
                ctx.scale(dpr, dpr);

                ctx.fillStyle = "#16213e";
                ctx.fillRect(0, 0, pw, ph);

                // Account for scrollbar: draw area must match lane canvas width
                const drawW = pw - LABEL_W - (scrollbarW || 0);
                if (drawW <= 0) return;

                function fmtDur(ns) {
                    if (ns >= 1e6) return (ns / 1e6).toFixed(2) + "ms";
                    if (ns >= 1e3) return (ns / 1e3).toFixed(1) + "Âµs";
                    return ns.toFixed(0) + "ns";
                }

                const bandTop = 50, bandH = 30;
                ctx.font = "9px monospace";
                ctx.textAlign = "center";

                // For each poll, find the most recent wake before it to show wakeâ†’poll delay
                const pollWakes = []; // parallel to polls: {wake, effectiveWake} or null
                for (let pi = 0; pi < polls.length; pi++) {
                    const s = polls[pi];
                    let best = null;
                    if (wakes.length) {
                        let lo = 0, hi = wakes.length - 1, bi = -1;
                        while (lo <= hi) {
                            const mid = (lo + hi) >> 1;
                            if (wakes[mid].timestamp <= s.start) { bi = mid; lo = mid + 1; }
                            else hi = mid - 1;
                        }
                        if (bi >= 0) {
                            const w = wakes[bi];
                            // If wake arrived during an earlier poll, effective wait starts at that poll's end
                            let effectiveWake = w.timestamp;
                            for (let j = 0; j < pi; j++) {
                                if (w.timestamp >= polls[j].start && w.timestamp <= polls[j].end) {
                                    effectiveWake = polls[j].end;
                                    break;
                                }
                            }
                            const delay = s.start - effectiveWake;
                            if (delay >= 0 && delay < 1e9) best = { wake: w, effectiveWake };
                        }
                    }
                    pollWakes.push(best);
                }

                // Draw wakeâ†’poll scheduling delay regions
                taskDetailWakeRegions = [];
                taskDetailHitRegions = [];
                for (let i = 0; i < polls.length; i++) {
                    const pollWake = pollWakes[i];
                    if (!pollWake) continue;
                    const { wake, effectiveWake } = pollWake;
                    const s = polls[i];
                    if (s.start < viewStart || effectiveWake > viewEnd) continue;
                    const delay = s.start - effectiveWake;
                    const x1 = LABEL_W + Math.max(0, nsToX(effectiveWake, drawW));
                    const x2 = LABEL_W + Math.min(drawW, nsToX(s.start, drawW));
                    const w = x2 - x1;
                    if (w < 1) continue;

                    // Color by severity
                    const delayUs = delay / 1000;
                    if (delayUs > 1000) ctx.fillStyle = "rgba(255,50,50,0.3)";
                    else if (delayUs > 100) ctx.fillStyle = "rgba(255,150,50,0.3)";
                    else ctx.fillStyle = "rgba(100,200,100,0.15)";
                    ctx.fillRect(x1, bandTop, w, bandH);

                    // Dashed border
                    ctx.strokeStyle = delayUs > 1000 ? "#ff4444" : delayUs > 100 ? "#ff8a65" : "#555";
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.strokeRect(x1, bandTop, w, bandH);
                    ctx.setLineDash([]);

                    // Delay label above
                    if (w > 25) {
                        ctx.fillStyle = delayUs > 1000 ? "#ff4444" : delayUs > 100 ? "#ff8a65" : "#888";
                        ctx.fillText(fmtDur(delay), x1 + w / 2, bandTop - 6);
                    }

                    // Wake marker (triangle)
                    const wx = x1;
                    ctx.fillStyle = "#66bb6a";
                    ctx.beginPath();
                    ctx.moveTo(wx, bandTop + bandH + 2);
                    ctx.lineTo(wx - 4, bandTop + bandH + 9);
                    ctx.lineTo(wx + 4, bandTop + bandH + 9);
                    ctx.closePath();
                    ctx.fill();

                    // Hit region for scheduled section
                    taskDetailHitRegions.push({
                        x1, x2: x1 + w, y1: bandTop, y2: bandTop + bandH,
                        type: "scheduled",
                        detail: `Scheduled â€” waiting ${fmtDur(delay)} for worker to poll after wake`,
                    });

                    // Show waker info: spawn location for tracked tasks, "io" for runtime/worker wakes
                    {
                        let label;
                        const wid = wake.wakerTaskId;
                        if (!wid || wid === 0 || (wid >= 1 && wid <= workerIds.length)) {
                            label = "io";
                        } else {
                            const wakerLoc = trace.taskSpawnLocs.get(wid);
                            const wakerLocStr = wakerLoc ? trace.spawnLocations.get(wakerLoc) : null;
                            label = wakerLocStr ? wakerLocStr.replace(/.*\//, '') : `task 0x${wid.toString(16)}`;
                        }
                        if (w > 40) {
                            const isHovered = hoveredWakerTaskId === wake.wakerTaskId;
                            ctx.fillStyle = isHovered ? "#fff" : "#66bb6a";
                            ctx.font = isHovered ? "bold 8px monospace" : "8px monospace";
                            ctx.textAlign = "left";
                            ctx.fillText("â¬† " + label, wx, bandTop + bandH + 20);
                            ctx.font = "9px monospace";
                            // Record hit region for hover detection
                            taskDetailWakeRegions.push({
                                x1, x2: x1 + w,
                                y1: bandTop + bandH, y2: bandTop + bandH + 24,
                                wakerTaskId: wake.wakerTaskId,
                            });
                        }
                    }
                }

                // Draw poll spans
                for (const s of polls) {
                    if (s.end < viewStart || s.start > viewEnd) continue;
                    const x1 = LABEL_W + Math.max(0, nsToX(s.start, drawW));
                    const x2 = LABEL_W + Math.min(drawW, nsToX(s.end, drawW));
                    const w = Math.max(x2 - x1, 1);
                    ctx.fillStyle = "#4fc3f7";
                    ctx.fillRect(x1, bandTop, w, bandH);
                    if (w > 35) {
                        ctx.fillStyle = "#000";
                        ctx.fillText(fmtDur(s.end - s.start), x1 + w / 2, bandTop + bandH / 2 + 3);
                    }
                    // Hit region for polling section
                    taskDetailHitRegions.push({
                        x1, x2, y1: bandTop, y2: bandTop + bandH,
                        type: "polling",
                        detail: `Polling â€” actively executing for ${fmtDur(s.end - s.start)}`,
                    });
                }

                // Draw idle gaps between consecutive polls (where no wakeâ†’poll delay is shown)
                for (let i = 0; i < polls.length - 1; i++) {
                    const gapStart = polls[i].end;
                    const gapEnd = polls[i + 1].start;
                    if (gapEnd < viewStart || gapStart > viewEnd) continue;
                    // Skip if the next poll's wake covers this gap
                    const nextPw = pollWakes[i + 1];
                    const nextWakeTs = nextPw ? nextPw.effectiveWake : null;
                    if (nextWakeTs !== null && nextWakeTs <= gapStart) continue;
                    const x1 = LABEL_W + Math.max(0, nsToX(gapStart, drawW));
                    const wakeX = nextWakeTs !== null ? LABEL_W + Math.max(0, nsToX(nextWakeTs, drawW)) : LABEL_W + Math.min(drawW, nsToX(gapEnd, drawW));
                    const x2 = Math.min(wakeX, LABEL_W + Math.min(drawW, nsToX(gapEnd, drawW)));
                    const w = Math.max(x2 - x1, 0);
                    if (w < 1) continue;
                    ctx.fillStyle = "#2a2a4a";
                    ctx.fillRect(x1, bandTop, w, bandH);
                    ctx.strokeStyle = "#444";
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]);
                    ctx.strokeRect(x1, bandTop, w, bandH);
                    ctx.setLineDash([]);
                    const dur = (nextWakeTs !== null ? nextWakeTs : gapEnd) - gapStart;
                    ctx.fillStyle = dur > 1e6 ? "#ff8a65" : "#888";
                    if (w > 35) {
                        ctx.fillText(fmtDur(dur), x1 + w / 2, bandTop - 6);
                    }
                    // Hit region for idle section
                    taskDetailHitRegions.push({
                        x1, x2, y1: bandTop, y2: bandTop + bandH,
                        type: "idle",
                        detail: `Idle â€” waiting ${fmtDur(dur)} for waker (no wake received yet)`,
                    });
                }

                // Legend
                ctx.fillStyle = "#aaa";
                ctx.font = "9px monospace";
                ctx.textAlign = "left";
                ctx.fillText("Task", 12, bandTop + bandH / 2 + 4);
                ctx.fillStyle = "#66bb6a";
                ctx.fillText("â–² = wake", 12, bandTop + bandH + 18);
            }

            function renderQueueChart(drawW, scrollbarW) {
                const c = queueCanvas;
                const parent = c.parentElement;
                const dpr = devicePixelRatio || 1;
                const pw = parent.clientWidth,
                    ph = parent.clientHeight;
                c.width = pw * dpr;
                c.height = ph * dpr;
                c.style.width = pw + "px";
                c.style.height = ph + "px";
                const ctx = c.getContext("2d");
                ctx.scale(dpr, dpr);

                ctx.fillStyle = "#16213e";
                ctx.fillRect(0, 0, pw, ph);

                if (!queueSamples.length) return;

                const chartLeft = LABEL_W,
                    chartW = pw - LABEL_W - (scrollbarW || 0);
                const chartTop = 24,
                    chartH = ph - 30;
                if (chartW <= 0) return;

                // Bucket samples into pixels â€” take max global and max local per pixel bucket
                const numBuckets = Math.ceil(chartW);
                const buckets = new Array(numBuckets);
                for (let i = 0; i < numBuckets; i++)
                    buckets[i] = { maxGlobal: 0, maxLocal: 0, hasData: false };

                const viewDur = viewEnd - viewStart;
                // Global queue from QueueSample events
                for (const s of queueSamples) {
                    if (s.t < viewStart || s.t > viewEnd) continue;
                    const bi = Math.floor(
                        ((s.t - viewStart) / viewDur) * (numBuckets - 1),
                    );
                    if (bi < 0 || bi >= numBuckets) continue;
                    const b = buckets[bi];
                    b.hasData = true;
                    if (s.global > b.maxGlobal) b.maxGlobal = s.global;
                }
                // Build sorted timeline of all local queue changes
                const allLocalSamples = [];
                for (const w of workerIds) {
                    const wSamples = workerQueueSamples[w] || [];
                    for (const s of wSamples) {
                        if (s.t >= viewStart && s.t <= viewEnd) {
                            allLocalSamples.push({ t: s.t, w, local: s.local });
                        }
                    }
                }
                allLocalSamples.sort((a, b) => a.t - b.t);
                
                // Single pass: maintain per-worker state and compute max for each bucket
                const workerState = {};
                for (const w of workerIds) workerState[w] = 0;
                let sampleIdx = 0;
                
                for (let bi = 0; bi < numBuckets; bi++) {
                    const bucketEnd = viewStart + ((bi + 1) / numBuckets) * viewDur;
                    
                    // Apply all samples up to this bucket's end
                    while (sampleIdx < allLocalSamples.length && allLocalSamples[sampleIdx].t < bucketEnd) {
                        const s = allLocalSamples[sampleIdx];
                        workerState[s.w] = s.local;
                        buckets[bi].hasData = true;
                        sampleIdx++;
                    }
                    
                    // Max across all workers
                    let max = 0;
                    for (const w of workerIds) {
                        if (workerState[w] > max) max = workerState[w];
                    }
                    buckets[bi].maxLocal = max;
                }

                // Find max for scaling
                let maxQ = 1;
                for (const b of buckets) {
                    if (b.maxGlobal > maxQ) maxQ = b.maxGlobal;
                    if (b.maxLocal > maxQ) maxQ = b.maxLocal;
                }

                // Y-axis labels
                ctx.fillStyle = "#666";
                ctx.font = "10px monospace";
                ctx.textAlign = "right";
                ctx.fillText(maxQ.toString(), LABEL_W - 6, chartTop + 10);
                ctx.fillText("0", LABEL_W - 6, chartTop + chartH);

                // Draw global queue as filled step area
                ctx.beginPath();
                ctx.moveTo(chartLeft, chartTop + chartH);
                let lastY = chartTop + chartH;
                for (let i = 0; i < numBuckets; i++) {
                    const x = chartLeft + i;
                    if (buckets[i].hasData) {
                        lastY =
                            chartTop +
                            chartH -
                            (buckets[i].maxGlobal / maxQ) * chartH;
                    }
                    ctx.lineTo(x, lastY);
                }
                ctx.lineTo(chartLeft + numBuckets - 1, chartTop + chartH);
                ctx.closePath();
                ctx.fillStyle = "rgba(79,195,247,0.3)";
                ctx.fill();
                ctx.strokeStyle = "#4fc3f7";
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw max local queue as step line
                ctx.beginPath();
                lastY = chartTop + chartH;
                let started = false;
                for (let i = 0; i < numBuckets; i++) {
                    const x = chartLeft + i;
                    if (buckets[i].hasData) {
                        lastY =
                            chartTop +
                            chartH -
                            (buckets[i].maxLocal / maxQ) * chartH;
                    }
                    if (!started) {
                        ctx.moveTo(x, lastY);
                        started = true;
                    } else ctx.lineTo(x, lastY);
                }
                ctx.strokeStyle = "#ff8a65";
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            function renderCrosshair() {
                const overlay = document.getElementById("crosshair-overlay");
                const mainArea = document.getElementById("main-area");
                const dpr = devicePixelRatio || 1;
                const w = mainArea.clientWidth, h = mainArea.clientHeight;
                overlay.width = w * dpr;
                overlay.height = h * dpr;
                overlay.style.width = w + "px";
                overlay.style.height = h + "px";
                const ctx = overlay.getContext("2d");
                ctx.scale(dpr, dpr);
                ctx.clearRect(0, 0, w, h);
                if (mouseNs === null || mouseNs < viewStart || mouseNs > viewEnd) return;

                // Compute x position aligned with the lanes (lanes start after LABEL_W within lanes-container)
                const lanesRect = lanesContainer.getBoundingClientRect();
                const mainRect = mainArea.getBoundingClientRect();
                const laneDrawW = lanesRect.width - LABEL_W;
                const scrollbarW = lanesContainer.offsetWidth - lanesContainer.clientWidth;
                const x = (lanesRect.left - mainRect.left) + LABEL_W + nsToX(mouseNs, laneDrawW - scrollbarW);

                ctx.strokeStyle = "rgba(255,255,255,0.3)";
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // â”€â”€ Zoom & Pan â”€â”€
            document.getElementById("poi-filter").addEventListener("change", updatePointsOfInterest);
            document.getElementById("sort-by-worst").addEventListener("change", updatePointsOfInterest);
            document.getElementById("btn-sched-panel").addEventListener("click", showSchedPanel);
            document.getElementById("btn-prev-poi").addEventListener("click", () => {
                if (currentPoiIndex > 0) jumpToPoi(currentPoiIndex - 1);
                else if (currentPoiIndex < 0 && pointsOfInterest.length > 0) jumpToPoi(0);
            });
            document.getElementById("btn-next-poi").addEventListener("click", () => {
                if (currentPoiIndex < pointsOfInterest.length - 1) jumpToPoi(currentPoiIndex + 1);
                else if (currentPoiIndex < 0 && pointsOfInterest.length > 0) jumpToPoi(0);
            });
            document
                .getElementById("btn-zoom-in")
                .addEventListener("click", () => zoom(0.5));
            document
                .getElementById("btn-zoom-out")
                .addEventListener("click", () => zoom(2));
            document.getElementById("btn-fit").addEventListener("click", () => {
                viewStart = minTs;
                viewEnd = maxTs;
                renderAll();
            });

            function zoom(factor, centerFrac = 0.5) {
                const viewDur = viewEnd - viewStart;
                const center = viewStart + viewDur * centerFrac;
                const newDur = Math.max(viewDur * factor, 100); // min 100ns
                viewStart = Math.max(minTs, center - newDur * centerFrac);
                viewEnd = Math.min(maxTs, center + newDur * (1 - centerFrac));
                renderAll();
            }

            // Mouse wheel zoom on main area
            document.getElementById("main-area").addEventListener(
                "wheel",
                (e) => {
                    if (document.getElementById("flamegraph-panel").style.display === "flex") return;
                    e.preventDefault();
                    const rect = lanesContainer.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left - LABEL_W;
                    const drawW = rect.width - LABEL_W;
                    const frac = Math.max(0, Math.min(1, mouseX / drawW));
                    const factor = e.deltaY > 0 ? 1.3 : 1 / 1.3;
                    zoom(factor, frac);
                },
                { passive: false },
            );

            // Pan with mouse drag (normal) or region select (shift+drag)
            let dragging = false,
                dragStartX = 0,
                dragViewStart = 0,
                dragViewEnd = 0,
                dragMoved = false;
            let regionSelecting = false,
                regionStartNs = 0,
                regionEndNs = 0;
            const selOverlay = document.getElementById("selection-overlay");

            document
                .getElementById("main-area")
                .addEventListener("mousedown", (e) => {
                    if (e.shiftKey && trace && trace.cpuSamples.length > 0) {
                        // Shift+drag: region select
                        regionSelecting = true;
                        dragMoved = false;
                        dragStartX = e.clientX;
                        const rect = lanesContainer.getBoundingClientRect();
                        const mouseX = e.clientX - rect.left - LABEL_W;
                        const drawW = rect.width - LABEL_W;
                        regionStartNs = viewStart + (Math.max(0, mouseX) / drawW) * (viewEnd - viewStart);
                        regionEndNs = regionStartNs;
                        // Position overlay
                        const mainRect = document.getElementById("main-area").getBoundingClientRect();
                        selOverlay.style.top = "0px";
                        selOverlay.style.height = mainRect.height + "px";
                        selOverlay.style.display = "block";
                        updateSelOverlay(e.clientX);
                        document.body.style.cursor = "crosshair";
                        return;
                    }
                    dragging = true;
                    dragMoved = false;
                    dragStartX = e.clientX;
                    dragViewStart = viewStart;
                    dragViewEnd = viewEnd;
                    document.body.style.cursor = "grabbing";
                });

            function updateSelOverlay(clientX) {
                const rect = lanesContainer.getBoundingClientRect();
                const drawW = rect.width - LABEL_W;
                const mainRect = document.getElementById("main-area").getBoundingClientRect();
                const lanesLeft = rect.left - mainRect.left + LABEL_W;
                const x1 = lanesLeft + nsToX(Math.min(regionStartNs, regionEndNs), drawW);
                const x2 = lanesLeft + nsToX(Math.max(regionStartNs, regionEndNs), drawW);
                selOverlay.style.left = x1 + "px";
                selOverlay.style.width = Math.max(1, x2 - x1) + "px";
            }

            window.addEventListener("mousemove", (e) => {
                if (regionSelecting) {
                    if (Math.abs(e.clientX - dragStartX) > 3) dragMoved = true;
                    const rect = lanesContainer.getBoundingClientRect();
                    const drawW = rect.width - LABEL_W;
                    const mouseX = e.clientX - rect.left - LABEL_W;
                    regionEndNs = viewStart + (Math.max(0, Math.min(drawW, mouseX)) / drawW) * (viewEnd - viewStart);
                    updateSelOverlay(e.clientX);
                    return;
                }
                if (!dragging) return;
                if (Math.abs(e.clientX - dragStartX) > 3) dragMoved = true;
                const rect = lanesContainer.getBoundingClientRect();
                const drawW = rect.width - LABEL_W;
                const dx = e.clientX - dragStartX;
                const nsPerPx = (dragViewEnd - dragViewStart) / drawW;
                const shift = -dx * nsPerPx;
                let newStart = dragViewStart + shift;
                let newEnd = dragViewEnd + shift;
                // Clamp
                if (newStart < minTs) {
                    newEnd += minTs - newStart;
                    newStart = minTs;
                }
                if (newEnd > maxTs) {
                    newStart -= newEnd - maxTs;
                    newEnd = maxTs;
                }
                viewStart = Math.max(minTs, newStart);
                viewEnd = Math.min(maxTs, newEnd);
                renderAll();
            });
            window.addEventListener("mouseup", () => {
                if (regionSelecting) {
                    regionSelecting = false;
                    selOverlay.style.display = "none";
                    document.body.style.cursor = "";
                    if (dragMoved) {
                        const selStart = Math.min(regionStartNs, regionEndNs);
                        const selEnd = Math.max(regionStartNs, regionEndNs);
                        // Check if there are sched events in range
                        const hasSched = collectSchedSamples({ start: selStart, end: selEnd }).length > 0;
                        if (hasSched) {
                            showSelectionPicker(selStart, selEnd);
                        } else {
                            showFlamegraph(selStart, selEnd);
                        }
                    }
                    return;
                }
                dragging = false;
                document.body.style.cursor = "";
            });

            // Click on a poll to highlight all polls for the same task
            document.getElementById("main-area").addEventListener("click", (e) => {
                if (dragMoved) return; // was a drag, not a click
                // Only handle clicks inside the lanes container
                const lanesRect = lanesContainer.getBoundingClientRect();
                if (e.clientY < lanesRect.top || e.clientY > lanesRect.bottom ||
                    e.clientX < lanesRect.left || e.clientX > lanesRect.right) return;
                const mouseX = e.clientX - lanesRect.left - LABEL_W;
                const mouseY = e.clientY - lanesRect.top;
                const drawW = lanesRect.width - LABEL_W;
                if (mouseX < 0 || mouseX > drawW) { selectedTaskId = null; renderAll(); return; }

                const ns = viewStart + (mouseX / drawW) * (viewEnd - viewStart);
                const laneIdx = Math.floor((mouseY + lanesContainer.scrollTop) / LANE_H);
                if (laneIdx < 0 || laneIdx >= workerIds.length) { selectedTaskId = null; renderAll(); return; }

                const w = workerIds[laneIdx];
                const spans = workerSpans[w];
                let found = null;
                let foundSpan = null;
                for (const s of spans.polls) {
                    if (ns >= s.start && ns <= s.end) {
                        if (s.taskId) found = s.taskId;
                        foundSpan = s;
                        break;
                    }
                }

                // Show stack popup if poll has CPU samples or sched events
                if (foundSpan && ((foundSpan.cpuSamples && foundSpan.cpuSamples.length > 0) ||
                                  (foundSpan.schedSamples && foundSpan.schedSamples.length > 0))) {
                    showStackPopup(foundSpan, e.clientX, e.clientY);
                } else {
                    hideStackPopup();
                }

                selectedTaskId = (found && found !== selectedTaskId) ? found : null;
                renderAll();
            });

            function symbolizeChain(chain) {
                return chain.map(addr => trace.callframeSymbols.get(addr) || addr);
            }

            // Shorten a symbol for display: strip generic params, keep last path segment
            function shortSym(sym) {
                // Strip everything inside < > for readability
                return sym.replace(/<[^>]*>/g, '<â€¦>');
            }

            function showStackPopup(poll, x, y) {
                const popup = document.getElementById("stack-popup");
                const title = document.getElementById("stack-popup-title");
                const body = document.getElementById("stack-popup-body");
                const durUs = ((poll.end - poll.start) / 1e3).toFixed(1);
                const cpuCount = poll.cpuSamples ? poll.cpuSamples.length : 0;
                const schedCount = poll.schedSamples ? poll.schedSamples.length : 0;
                title.textContent = `Poll ${durUs}Âµs` +
                    (cpuCount ? ` Â· ${cpuCount} CPU sample${cpuCount > 1 ? "s" : ""}` : "") +
                    (schedCount ? ` Â· ${schedCount} sched event${schedCount > 1 ? "s" : ""}` : "");

                let html = "";

                // Sched events: deduplicate by symbolized stack, show counts
                if (poll.schedSamples && poll.schedSamples.length > 0) {
                    html += `<div style="color:#ff4444;font-weight:600;margin-bottom:6px">âš  Blocking during poll (${schedCount} sched event${schedCount > 1 ? "s" : ""})</div>`;
                    const groups = deduplicateSamples(poll.schedSamples);
                    for (const g of groups) {
                        const pct = ((g.count / schedCount) * 100).toFixed(0);
                        const barW = Math.max(2, (g.count / schedCount) * 200);
                        html += `<div style="margin-bottom:10px;border-left:3px solid #ff4444;padding-left:8px">`;
                        html += `<div style="display:flex;align-items:center;gap:8px;margin-bottom:4px">`;
                        html += `<span style="color:#ff4444;font-weight:600;font-size:1.1em">${g.count}Ã—</span>`;
                        html += `<span style="color:#fff;font-weight:600">${shortSym(g.leaf)}</span>`;
                        html += `<span style="color:#888">(${pct}%)</span>`;
                        html += `<span style="display:inline-block;height:8px;width:${barW}px;background:#ff4444;border-radius:2px;opacity:0.6"></span>`;
                        html += `</div>`;
                        // Show abbreviated context: leaf + first interesting caller
                        const ctx = g.syms.slice(0, 3);
                        for (let i = 0; i < ctx.length; i++) {
                            html += `<div style="color:${i === 0 ? '#ff8a65' : '#777'};padding-left:${i * 8}px;font-size:0.9em">${shortSym(ctx[i])}</div>`;
                        }
                        if (g.syms.length > 3) {
                            const id = 'sched-expand-' + Math.random().toString(36).slice(2);
                            html += `<div id="${id}-toggle" style="color:#6c63ff;cursor:pointer;font-size:0.85em;padding-left:16px" onclick="document.getElementById('${id}').style.display=document.getElementById('${id}').style.display==='none'?'block':'none';this.textContent=this.textContent.startsWith('â–¶')?'â–¼ collapse':'â–¶ ${g.syms.length - 3} more frames'">â–¶ ${g.syms.length - 3} more frames</div>`;
                            html += `<div id="${id}" style="display:none">`;
                            for (let i = 3; i < g.syms.length; i++) {
                                html += `<div style="color:#666;padding-left:24px;font-size:0.85em">${shortSym(g.syms[i])}</div>`;
                            }
                            html += `</div>`;
                        }
                        html += `</div>`;
                    }
                }

                // CPU profile samples: same dedup treatment
                if (poll.cpuSamples && poll.cpuSamples.length > 0) {
                    if (schedCount > 0) {
                        html += `<div style="color:#ff8c00;font-weight:600;margin:8px 0 6px">CPU Profile (${cpuCount} sample${cpuCount > 1 ? "s" : ""})</div>`;
                    }
                    const groups = deduplicateSamples(poll.cpuSamples);
                    for (const g of groups) {
                        const pct = ((g.count / cpuCount) * 100).toFixed(0);
                        html += `<div style="margin-bottom:8px;border-left:2px solid #333;padding-left:8px">`;
                        html += `<span style="color:#ff8c00">${g.count}Ã—</span> `;
                        html += `<span style="color:#fff">${shortSym(g.leaf)}</span> `;
                        html += `<span style="color:#888">(${pct}%)</span>`;
                        const ctx = g.syms.slice(1, 3);
                        for (const s of ctx) {
                            html += `<div style="color:#777;padding-left:8px;font-size:0.9em">${shortSym(s)}</div>`;
                        }
                        if (g.syms.length > 3) {
                            const id = 'cpu-expand-' + Math.random().toString(36).slice(2);
                            html += `<div id="${id}-toggle" style="color:#6c63ff;cursor:pointer;font-size:0.85em;padding-left:8px" onclick="document.getElementById('${id}').style.display=document.getElementById('${id}').style.display==='none'?'block':'none';this.textContent=this.textContent.startsWith('â–¶')?'â–¼ collapse':'â–¶ ${g.syms.length - 3} more frames'">â–¶ ${g.syms.length - 3} more frames</div>`;
                            html += `<div id="${id}" style="display:none">`;
                            for (let i = 3; i < g.syms.length; i++) {
                                html += `<div style="color:#666;padding-left:16px;font-size:0.85em">${shortSym(g.syms[i])}</div>`;
                            }
                            html += `</div>`;
                        }
                        html += `</div>`;
                    }
                }

                body.innerHTML = html;
                popup.style.display = "block";
                popup.style.left = Math.min(x + 12, window.innerWidth - 820) + "px";
                popup.style.top = Math.min(y - 20, window.innerHeight - 620) + "px";
            }

            // Deduplicate samples by symbolized stack, return sorted groups
            function deduplicateSamples(samples) {
                const groups = new Map(); // key â†’ {count, syms, leaf}
                for (const sample of samples) {
                    const syms = symbolizeChain(sample.callchain);
                    const key = syms.join('\0');
                    if (!groups.has(key)) {
                        groups.set(key, { count: 0, syms, leaf: syms[0] || '(unknown)' });
                    }
                    groups.get(key).count++;
                }
                return [...groups.values()].sort((a, b) => b.count - a.count);
            }

            function hideStackPopup() {
                document.getElementById("stack-popup").style.display = "none";
            }

            document.getElementById("stack-popup-close").addEventListener("click", hideStackPopup);
            // Close popup when clicking outside it
            document.addEventListener("click", (e) => {
                const popup = document.getElementById("stack-popup");
                if (popup.style.display !== "none" && !popup.contains(e.target) &&
                    !e.target.closest("#main-area")) {
                    hideStackPopup();
                }
            });

            // â”€â”€ Sched Events Panel (global view of all blocking operations) â”€â”€
            let schedPanelTimeRange = null; // {start, end} or null for full trace

            function showSchedPanel(startNs, endNs) {
                schedPanelTimeRange = (startNs != null && endNs != null) ? { start: startNs, end: endNs } : null;
                const allSched = collectSchedSamples(schedPanelTimeRange);
                if (!allSched.length) {
                    alert("No scheduling events found" + (schedPanelTimeRange ? " in selected range." : " in this trace."));
                    return;
                }
                renderSchedPanel(allSched);
                document.getElementById("sched-panel").style.display = "flex";
            }

            function collectSchedSamples(range) {
                const allSched = [];
                for (const w of workerIds) {
                    for (const poll of workerSpans[w].polls) {
                        if (!poll.schedSamples) continue;
                        if (range && (poll.end < range.start || poll.start > range.end)) continue;
                        for (const s of poll.schedSamples) {
                            if (range && (s.timestamp < range.start || s.timestamp > range.end)) continue;
                            allSched.push({ sample: s, poll, worker: w });
                        }
                    }
                }
                return allSched;
            }

            function renderSchedPanel(allSched) {
                const groupBy = document.getElementById("sched-group-by").value;
                const body = document.getElementById("sched-panel-body");
                const total = allSched.length;
                const rangeLabel = schedPanelTimeRange
                    ? ` in ${((schedPanelTimeRange.end - schedPanelTimeRange.start) / 1e6).toFixed(2)}ms selection`
                    : " (full trace)";
                document.getElementById("sched-panel-stats").textContent =
                    `${total} events across ${workerIds.length} workers${rangeLabel}`;

                // Group by leaf frame or full stack
                const groups = new Map();
                for (const { sample, poll, worker } of allSched) {
                    const syms = symbolizeChain(sample.callchain);
                    const key = groupBy === "leaf" ? (syms[0] || "(unknown)") : syms.join('\0');
                    if (!groups.has(key)) {
                        groups.set(key, { leaf: syms[0] || "(unknown)", count: 0, stacks: new Map(), polls: [] });
                    }
                    const g = groups.get(key);
                    g.count++;
                    g.polls.push({ poll, worker, timestamp: sample.timestamp });
                    // Sub-group by full stack within each leaf group
                    const fullKey = syms.join('\0');
                    if (!g.stacks.has(fullKey)) {
                        g.stacks.set(fullKey, { count: 0, syms });
                    }
                    g.stacks.get(fullKey).count++;
                }

                const sorted = [...groups.values()].sort((a, b) => b.count - a.count);

                let html = `<div style="margin-bottom:12px;color:#aaa;font-size:0.9em">
                    Blocking calls that caused the kernel to deschedule a tokio worker thread during a poll.
                    These indicate synchronous/blocking operations on the async runtime.
                </div>`;

                // Summary bar chart
                html += `<div style="margin-bottom:16px">`;
                for (const g of sorted) {
                    const pct = ((g.count / total) * 100).toFixed(1);
                    const barW = Math.max(4, (g.count / total) * 100);
                    const color = g.leaf.includes("lock") || g.leaf.includes("mutex") ? "#ff4444"
                        : g.leaf.includes("epoll") || g.leaf.includes("poll") ? "#4fc3f7"
                        : g.leaf.includes("write") || g.leaf.includes("read") || g.leaf.includes("recv") || g.leaf.includes("send") ? "#ff8a65"
                        : g.leaf.includes("syscall") ? "#888"
                        : "#cc66ff";
                    html += `<div style="display:flex;align-items:center;gap:8px;margin-bottom:3px;cursor:pointer" class="sched-row" data-leaf="${encodeURIComponent(g.leaf)}">`;
                    html += `<span style="width:50px;text-align:right;color:${color};font-weight:600">${g.count}</span>`;
                    html += `<span style="display:inline-block;height:14px;width:${barW}%;background:${color};border-radius:2px;opacity:0.7"></span>`;
                    html += `<span style="color:#fff">${g.leaf}</span>`;
                    html += `<span style="color:#666">${pct}%</span>`;
                    html += `</div>`;
                }
                html += `</div>`;

                // Detailed stacks per group
                for (const g of sorted) {
                    const pct = ((g.count / total) * 100).toFixed(1);
                    const color = g.leaf.includes("lock") || g.leaf.includes("mutex") ? "#ff4444" : "#ff8a65";
                    const gid = 'sg-' + Math.random().toString(36).slice(2);

                    html += `<div style="border:1px solid #333;border-radius:6px;margin-bottom:8px;overflow:hidden">`;
                    html += `<div style="padding:8px 12px;background:#16213e;display:flex;align-items:center;gap:8px;cursor:pointer" onclick="document.getElementById('${gid}').style.display=document.getElementById('${gid}').style.display==='none'?'block':'none'">`;
                    html += `<span style="color:${color};font-weight:700;font-size:1.1em">${g.count}Ã—</span>`;
                    html += `<span style="color:#fff;font-weight:600">${g.leaf}</span>`;
                    html += `<span style="color:#888">(${pct}% of all sched events)</span>`;
                    html += `<span style="color:#6c63ff;margin-left:auto;font-size:0.9em">â–¼ details</span>`;
                    html += `</div>`;

                    html += `<div id="${gid}" style="display:none;padding:8px 12px">`;

                    // Show unique stacks within this group
                    const subStacks = [...g.stacks.values()].sort((a, b) => b.count - a.count);
                    for (const sub of subStacks) {
                        const subPct = ((sub.count / g.count) * 100).toFixed(0);
                        html += `<div style="margin-bottom:10px;border-left:3px solid ${color};padding-left:10px">`;
                        html += `<div style="color:${color};margin-bottom:2px"><strong>${sub.count}Ã—</strong> <span style="color:#888">(${subPct}% of group)</span></div>`;
                        // Show full symbolized stack
                        for (let i = 0; i < sub.syms.length; i++) {
                            const isLeaf = i === 0;
                            const isTokio = sub.syms[i].includes("tokio::runtime");
                            const c = isLeaf ? "#fff" : isTokio ? "#555" : "#aaa";
                            const weight = isLeaf ? "font-weight:600" : "";
                            html += `<div style="color:${c};${weight};padding-left:${Math.min(i, 1) * 12}px">${shortSym(sub.syms[i])}</div>`;
                        }
                        html += `</div>`;
                    }

                    // Jump-to links: show a few example polls
                    const examples = g.polls.slice(0, 5);
                    html += `<div style="margin-top:6px;color:#6c63ff;font-size:0.9em">`;
                    html += `Example polls: `;
                    for (let i = 0; i < examples.length; i++) {
                        const ex = examples[i];
                        const tMs = ((ex.poll.start - minTs) / 1e6).toFixed(2);
                        const durUs = ((ex.poll.end - ex.poll.start) / 1e3).toFixed(0);
                        html += `<span class="sched-jump" style="cursor:pointer;text-decoration:underline;margin-right:8px" data-time="${ex.poll.start}" data-end="${ex.poll.end}" data-worker="${ex.worker}">W${ex.worker} @${tMs}ms (${durUs}Âµs)</span>`;
                    }
                    if (g.polls.length > 5) html += `<span style="color:#888">â€¦ ${g.polls.length - 5} more</span>`;
                    html += `</div>`;

                    html += `</div></div>`;
                }

                body.innerHTML = html;

                // Wire up jump-to-poll links
                body.querySelectorAll('.sched-jump').forEach(el => {
                    el.addEventListener('click', (e) => {
                        const t = parseFloat(el.dataset.time);
                        const end = parseFloat(el.dataset.end);
                        const w = parseInt(el.dataset.worker);
                        const dur = end - t;
                        const pad = Math.max(dur * 5, 1e6);
                        viewStart = Math.max(minTs, t - pad * 0.3);
                        viewEnd = Math.min(maxTs, viewStart + pad);
                        document.getElementById("sched-panel").style.display = "none";
                        // Scroll to worker lane
                        const laneIdx = workerIds.indexOf(w);
                        if (laneIdx >= 0) lanesContainer.scrollTop = laneIdx * LANE_H;
                        renderAll();
                    });
                });
            }

            document.getElementById("sched-group-by").addEventListener("change", () => {
                const allSched = collectSchedSamples(schedPanelTimeRange);
                renderSchedPanel(allSched);
            });

            document.getElementById("sched-panel-close").addEventListener("click", () => {
                document.getElementById("sched-panel").style.display = "none";
            });

            // â”€â”€ Keyboard navigation â”€â”€
            window.addEventListener("keydown", (e) => {
                if (!trace) return;
                const viewDur = viewEnd - viewStart;
                switch (e.key) {
                    case "Escape":
                        e.preventDefault();
                        hideStackPopup();
                        if (document.getElementById("sched-panel").style.display === "flex") {
                            document.getElementById("sched-panel").style.display = "none";
                        } else if (document.getElementById("flamegraph-panel").style.display === "flex") {
                            document.getElementById("flamegraph-panel").style.display = "none";
                            document.getElementById("fg-tooltip").style.display = "none";
                        }
                        selectedTaskId = null;
                        renderAll();
                        break;
                    case "ArrowUp":
                        e.preventDefault();
                        zoom(0.5);
                        break;
                    case "ArrowDown":
                        e.preventDefault();
                        zoom(2);
                        break;
                    case "ArrowLeft": {
                        e.preventDefault();
                        const shift = viewDur * 0.2;
                        viewStart = Math.max(minTs, viewStart - shift);
                        viewEnd = viewStart + viewDur;
                        if (viewEnd > maxTs) {
                            viewEnd = maxTs;
                            viewStart = viewEnd - viewDur;
                        }
                        renderAll();
                        break;
                    }
                    case "ArrowRight": {
                        e.preventDefault();
                        const shift = viewDur * 0.2;
                        viewEnd = Math.min(maxTs, viewEnd + shift);
                        viewStart = viewEnd - viewDur;
                        if (viewStart < minTs) {
                            viewStart = minTs;
                            viewEnd = viewStart + viewDur;
                        }
                        renderAll();
                        break;
                    }
                }
            });

            // â”€â”€ Tooltip â”€â”€
            document
                .getElementById("main-area")
                .addEventListener("mousemove", (e) => {
                    if (dragging) {
                        tooltip.style.display = "none";
                        mouseNs = null;
                        return;
                    }
                    if (document.getElementById("flamegraph-panel").style.display === "flex") {
                        tooltip.style.display = "none";
                        mouseNs = null;
                        return;
                    }
                    const rect = lanesContainer.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left - LABEL_W;
                    const mouseY = e.clientY - rect.top;
                    const drawW = rect.width - LABEL_W;
                    if (mouseX < 0 || mouseX > drawW) {
                        tooltip.style.display = "none";
                        mouseNs = null;
                        return;
                    }

                    const ns =
                        viewStart + (mouseX / drawW) * (viewEnd - viewStart);
                    mouseNs = ns;
                    
                    // Throttle crosshair redraw with RAF
                    if (!queueChartRafId) {
                        queueChartRafId = requestAnimationFrame(() => {
                            renderCrosshair();
                            queueChartRafId = null;
                        });
                    }

                    const laneIdx = Math.floor(
                        (mouseY + lanesContainer.scrollTop) / LANE_H,
                    );
                    if (laneIdx < 0 || laneIdx >= workerIds.length) {
                        tooltip.style.display = "none";
                        return;
                    }

                    const w = workerIds[laneIdx];
                    const spans = workerSpans[w];
                    const relMs = (ns - minTs) / 1e6;

                    // Determine worker state at this point in time
                    let state = "ðŸŸ¢ Active";
                    let stateDetail = "";
                    let schedInfo = "";
                    if (trace.hasCpuTime) {
                        for (const s of spans.actives) {
                            if (ns >= s.start && ns <= s.end) {
                                const pct = (s.ratio * 100).toFixed(1);
                                const icon = s.ratio >= 0.95 ? "ðŸŸ¢" : s.ratio >= 0.5 ? "ðŸŸ¡" : "ðŸ”´";
                                schedInfo = `<span class="label">Scheduling:</span> <span class="value">${icon} ${pct}% on-CPU</span><br>`;
                                break;
                            }
                        }
                    }
                    for (const s of spans.parks) {
                        if (ns >= s.start && ns <= s.end) {
                            const durMs = (s.end - s.start) / 1e6;
                            state = "ðŸ’¤ Parked";
                            stateDetail = ` for <span class="value">${durMs < 1 ? (durMs * 1000).toFixed(1) + "Âµs" : durMs.toFixed(2) + "ms"}</span>`;
                            schedInfo = "";
                            if (trace.hasSchedWait && s.schedWait != null) {
                                const swUs = s.schedWait;
                                const icon = swUs < 100 ? "ðŸŸ¢" : swUs < 1000 ? "ðŸŸ¡" : "ðŸ”´";
                                stateDetail += `<br><span class="label">Kernel sched delay:</span> <span class="value">${icon} ${swUs.toFixed(0)}Âµs</span>`;
                            }
                            break;
                        }
                    }

                    let pollInfo = "";
                    for (const s of spans.polls) {
                        if (ns >= s.start && ns <= s.end) {
                            const durUs = (s.end - s.start) / 1e3;
                            state = "âš¡ Polling";
                            pollInfo = `<span class="label">Poll duration:</span> <span class="value">${durUs.toFixed(1)}Âµs</span><br>`;
                            if (trace.hasTaskTracking && s.taskId) {
                                pollInfo += `<span class="label">Task ID:</span> <span class="value">0x${s.taskId.toString(16)}</span><br>`;
                                if (s.spawnLoc) {
                                    pollInfo += `<span class="label">Spawned at:</span> <span class="value">${s.spawnLoc}</span><br>`;
                                }
                            }
                            if (s.cpuSamples && s.cpuSamples.length > 0) {
                                pollInfo += `<span class="label">CPU samples:</span> <span class="value">ðŸ”¥ ${s.cpuSamples.length}</span> <span style="color:#666">(click to view)</span><br>`;
                            }
                            if (s.schedSamples && s.schedSamples.length > 0) {
                                pollInfo += `<span class="label">Sched events:</span> <span class="value">âš ï¸ ${s.schedSamples.length} blocking</span> <span style="color:#666">(click to view)</span><br>`;
                            }
                            break;
                        }
                    }

                    // Find nearest local queue sample for this worker
                    let nearest = null,
                        bestDist = Infinity;
                    const wSamples = workerQueueSamples[w] || [];
                    for (const s of wSamples) {
                        const d = Math.abs(s.t - ns);
                        if (d < bestDist) {
                            bestDist = d;
                            nearest = s;
                        }
                    }
                    // Find nearest global queue from QueueSample timeline
                    let nearestGlobal = null;
                    bestDist = Infinity;
                    for (const s of queueSamples) {
                        const d = Math.abs(s.t - ns);
                        if (d < bestDist) {
                            bestDist = d;
                            nearestGlobal = s;
                        }
                    }

                    let qInfo = "";
                    const globalStr = nearestGlobal != null ? nearestGlobal.global : "-";
                    const localStr = nearest != null ? nearest.local : "-";
                    const totalEst = (nearestGlobal != null ? nearestGlobal.global : 0) + (nearest != null ? nearest.local : 0);
                    qInfo = `<span class="label">Global Q:</span> <span class="value">${globalStr}</span> Â· <span class="label">Local Q:</span> <span class="value">${localStr}</span> Â· <span class="label">Est. Total:</span> <span class="value">${totalEst}</span>`;

                    tooltip.innerHTML =
                        `<span class="label">Worker</span> <span class="value">${w}</span> Â· <span class="label">Time</span> <span class="value">${relMs.toFixed(3)}ms</span><br>` +
                        `<span class="label">State:</span> ${state}${stateDetail}<br>` +
                        schedInfo +
                        pollInfo +
                        qInfo;
                    tooltip.style.display = "block";
                    tooltip.style.left =
                        Math.min(e.clientX + 12, window.innerWidth - 340) +
                        "px";
                    tooltip.style.top = e.clientY + 130 + "px";
                });
            document
                .getElementById("main-area")
                .addEventListener("mouseleave", () => {
                    tooltip.style.display = "none";
                    mouseNs = null;
                    renderCrosshair();
                });

            // â”€â”€ Resize â”€â”€
            // Task detail hover: highlight waker task polls on worker lanes + section tooltips
            document.getElementById("task-detail").addEventListener("mousemove", (e) => {
                const c = document.getElementById("task-detail-canvas");
                const rect = c.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                let found = null;
                for (const r of taskDetailWakeRegions) {
                    if (mx >= r.x1 && mx <= r.x2 && my >= r.y1 && my <= r.y2) {
                        found = r.wakerTaskId;
                        break;
                    }
                }
                if (found !== hoveredWakerTaskId) {
                    hoveredWakerTaskId = found;
                    document.getElementById("task-detail").style.cursor = found ? "pointer" : "";
                    renderAll();
                }

                // Show status for polling/scheduled/idle sections
                const statusEl = document.getElementById("task-detail-status");
                let hit = null;
                for (const r of taskDetailHitRegions) {
                    if (mx >= r.x1 && mx <= r.x2 && my >= r.y1 && my <= r.y2) {
                        hit = r;
                        break;
                    }
                }
                const icon = hit ? (hit.type === "polling" ? "âš¡" : hit.type === "scheduled" ? "â³" : "ðŸ’¤") : "";
                statusEl.textContent = hit ? `${icon} ${hit.detail}` : "";
            });
            document.getElementById("task-detail").addEventListener("mouseleave", () => {
                document.getElementById("task-detail-status").textContent = "";
                if (hoveredWakerTaskId) {
                    hoveredWakerTaskId = null;
                    renderAll();
                }
            });

            window.addEventListener("resize", () => {
                if (trace) renderAll();
            });

            // â”€â”€ Legend (inline in toolbar area) â”€â”€
            (function addLegend() {
                const tb = document.getElementById("toolbar");
                const leg = document.createElement("span");
                leg.style.cssText =
                    "font-size:0.8em;display:flex;gap:12px;align-items:center;";
                leg.innerHTML = `
    <span style="display:flex;align-items:center;gap:4px"><span style="width:12px;height:12px;background:#2a5a7a;display:inline-block;border-radius:2px"></span>Poll â‰¤10Âµs</span>
    <span style="display:flex;align-items:center;gap:4px"><span style="width:12px;height:12px;background:#4fc3f7;display:inline-block;border-radius:2px"></span>&gt;10Âµs</span>
    <span style="display:flex;align-items:center;gap:4px"><span style="width:12px;height:12px;background:#ff8a65;display:inline-block;border-radius:2px"></span>&gt;100Âµs</span>
    <span style="display:flex;align-items:center;gap:4px"><span style="width:12px;height:12px;background:#ff4444;display:inline-block;border-radius:2px"></span>&gt;1ms</span>
    <span style="display:flex;align-items:center;gap:4px"><span style="width:12px;height:12px;background:#2a1520;border-top:3px solid #cc5533;display:inline-block;border-radius:2px"></span>Parked</span>
    <span style="display:flex;align-items:center;gap:4px"><span style="width:12px;height:12px;background:#ff0000;display:inline-block;border-radius:2px"></span>Kernel Sched Delay</span>
    <span style="display:flex;align-items:center;gap:4px"><span style="width:12px;height:3px;background:#ff8c00;display:inline-block"></span>CPU Sampled</span>
    <span style="display:flex;align-items:center;gap:4px"><span style="color:#ff2222;font-size:10px">â–²</span>Sched (blocking)</span>
    <span style="display:flex;align-items:center;gap:4px"><span style="color:#66bb6a;font-size:10px">â–¼</span>Wake</span>
    <span style="display:flex;align-items:center;gap:4px"><span style="width:12px;height:2px;background:rgba(255,200,50,0.7);display:inline-block"></span>Local Q</span>
    <span style="color:#666;margin-left:8px">â”‚ â†‘â†“ zoom Â· â†â†’ pan Â· click poll for task + wake timeline Â· shift+drag for flamegraph Â· esc close</span>
  `;
                tb.insertBefore(leg, document.getElementById("btn-zoom-in"));
            })();

            // â”€â”€ Flamegraph â”€â”€
            let fgWorkerData = null;    // {nodes, maxDepth, totalSamples}
            let fgOffworkerData = null; // same shape, for worker 255
            const FG_ROW_H = 18;
            // Per-canvas hit regions
            let fgHitRegions = { worker: [], offworker: [] };
            // Raw samples for current flamegraph (for re-filtering)
            let fgAllSamples = [];

            function buildFlamegraphTree(samples) {
                const root = { name: "(all)", children: new Map(), count: 0, self: 0 };
                for (const s of samples) {
                    const chain = s.callchain.slice().reverse();
                    let node = root;
                    node.count++;
                    for (const addr of chain) {
                        const name = trace.callframeSymbols.get(addr) || addr;
                        if (!node.children.has(name)) {
                            node.children.set(name, { name, children: new Map(), count: 0, self: 0 });
                        }
                        node = node.children.get(name);
                        node.count++;
                    }
                    node.self++;
                }
                return root;
            }

            function flattenFlamegraph(root, total) {
                const nodes = [];
                let maxD = 0;
                function walk(node, depth, xStart) {
                    const w = node.count / total;
                    if (w < 0.001) return;
                    nodes.push({ name: node.name, depth, x: xStart, w, count: node.count, self: node.self });
                    if (depth > maxD) maxD = depth;
                    const kids = [...node.children.values()].sort((a, b) => b.count - a.count);
                    let cx = xStart;
                    for (const child of kids) {
                        walk(child, depth + 1, cx);
                        cx += child.count / total;
                    }
                }
                const kids = [...root.children.values()].sort((a, b) => b.count - a.count);
                let cx = 0;
                for (const child of kids) {
                    walk(child, 0, cx);
                    cx += child.count / total;
                }
                return { nodes, maxDepth: maxD };
            }

            function buildFgData(samples) {
                if (!samples.length) return null;
                const tree = buildFlamegraphTree(samples);
                const result = flattenFlamegraph(tree, samples.length);
                return { nodes: result.nodes, maxDepth: result.maxDepth, totalSamples: samples.length };
            }

            // Selection picker: shown after shift+drag when both flamegraph and sched data exist
            function showSelectionPicker(selStart, selEnd) {
                const durMs = ((selEnd - selStart) / 1e6).toFixed(2);
                const schedCount = collectSchedSamples({ start: selStart, end: selEnd }).length;
                const popup = document.getElementById("stack-popup");
                const title = document.getElementById("stack-popup-title");
                const body = document.getElementById("stack-popup-body");
                title.textContent = `${durMs}ms selected`;
                body.innerHTML = `
                    <div style="display:flex;flex-direction:column;gap:8px;min-width:250px">
                        <div style="padding:8px 12px;background:#2a2a4a;border:1px solid #444;border-radius:6px;cursor:pointer;transition:background 0.15s"
                             onmouseover="this.style.background='#3a3a5a'" onmouseout="this.style.background='#2a2a4a'"
                             id="pick-flamegraph">
                            <div style="color:#ff8c00;font-weight:600">ðŸ”¥ CPU Flamegraph</div>
                            <div style="color:#888;font-size:0.9em">Profile where CPU time is spent</div>
                        </div>
                        <div style="padding:8px 12px;background:#2a2a4a;border:1px solid #444;border-radius:6px;cursor:pointer;transition:background 0.15s"
                             onmouseover="this.style.background='#3a3a5a'" onmouseout="this.style.background='#2a2a4a'"
                             id="pick-sched">
                            <div style="color:#ff4444;font-weight:600">âš  Blocking Calls <span style="color:#888;font-weight:400">(${schedCount})</span></div>
                            <div style="color:#888;font-size:0.9em">Analyze what's blocking the runtime</div>
                        </div>
                    </div>`;
                popup.style.display = "block";
                // Center it roughly
                popup.style.left = (window.innerWidth / 2 - 150) + "px";
                popup.style.top = (window.innerHeight / 2 - 80) + "px";
                document.getElementById("pick-flamegraph").onclick = () => { hideStackPopup(); showFlamegraph(selStart, selEnd); };
                document.getElementById("pick-sched").onclick = () => { hideStackPopup(); showSchedPanel(selStart, selEnd); };
            }

            function showFlamegraph(selStart, selEnd) {
                const allSamples = trace.cpuSamples.filter(s =>
                    s.timestamp >= selStart && s.timestamp <= selEnd && s.callchain.length > 0 && s.source !== 1
                );
                if (!allSamples.length) {
                    alert("No CPU samples in selected region. CPU sampling must be active during this time range.");
                    return;
                }

                fgAllSamples = allSamples;
                const durMs = ((selEnd - selStart) / 1e6).toFixed(2);
                document.getElementById("fg-title").textContent = "Flamegraph";
                document.getElementById("fg-stats").textContent =
                    `${allSamples.length} samples Â· ${durMs}ms selected`;

                // Build spawn location dropdown
                const locCounts = new Map(); // spawnLoc â†’ count
                for (const s of allSamples) {
                    const loc = s.spawnLoc || "(unknown)";
                    locCounts.set(loc, (locCounts.get(loc) || 0) + 1);
                }
                const sel = document.getElementById("fg-spawn-filter");
                sel.innerHTML = `<option value="">All tasks (${allSamples.length} samples)</option>`;
                // Sort by count descending
                const sorted = [...locCounts.entries()].sort((a, b) => b[1] - a[1]);
                for (const [loc, count] of sorted) {
                    const short = loc.replace(/.*\//, '');
                    const opt = document.createElement("option");
                    opt.value = loc;
                    opt.textContent = `${short} (${count})`;
                    opt.title = loc;
                    sel.appendChild(opt);
                }

                document.getElementById("flamegraph-panel").style.display = "flex";
                applyFgFilter();
            }

            function applyFgFilter() {
                const filterVal = document.getElementById("fg-spawn-filter").value;
                const samples = filterVal
                    ? fgAllSamples.filter(s => (s.spawnLoc || "(unknown)") === filterVal)
                    : fgAllSamples;

                const workerSamples = samples.filter(s => s.workerId !== 255);
                const offworkerSamples = samples.filter(s => s.workerId === 255);

                fgWorkerData = buildFgData(workerSamples);
                fgOffworkerData = buildFgData(offworkerSamples);

                document.getElementById("fg-worker-label").textContent =
                    `Worker threads â€” ${workerSamples.length} samples`;
                document.getElementById("fg-worker-label").style.display = fgWorkerData ? "" : "none";
                document.getElementById("fg-canvas-worker").style.display = fgWorkerData ? "" : "none";

                const offLabel = document.getElementById("fg-offworker-label");
                offLabel.textContent =
                    `Off-worker (sampler thread) â€” ${offworkerSamples.length} samples`;
                offLabel.style.display = fgOffworkerData ? "" : "none";
                document.getElementById("fg-canvas-offworker").style.display = fgOffworkerData ? "" : "none";

                renderFlamegraph();
            }

            document.getElementById("fg-spawn-filter").addEventListener("change", applyFgFilter);

            function flamegraphColor(name) {
                let h = 0;
                for (let i = 0; i < name.length; i++) h = (h * 31 + name.charCodeAt(i)) | 0;
                const hue = 10 + (Math.abs(h) % 40);
                const sat = 60 + (Math.abs(h >> 8) % 30);
                const lit = 40 + (Math.abs(h >> 16) % 15);
                return `hsl(${hue},${sat}%,${lit}%)`;
            }

            function renderFgCanvas(canvasId, data, hitKey) {
                const c = document.getElementById(canvasId);
                if (!data) { c.width = 0; c.height = 0; fgHitRegions[hitKey] = []; return; }
                const dpr = devicePixelRatio || 1;
                const pw = c.parentElement.clientWidth;
                const ph = (data.maxDepth + 2) * FG_ROW_H + 8;
                c.width = pw * dpr;
                c.height = ph * dpr;
                c.style.width = pw + "px";
                c.style.height = ph + "px";
                const ctx = c.getContext("2d");
                ctx.scale(dpr, dpr);
                ctx.fillStyle = "#1a1a2e";
                ctx.fillRect(0, 0, pw, ph);

                const regions = [];
                const padL = 4, padR = 4, drawW = pw - padL - padR;
                const baseY = ph - 4;
                ctx.font = "11px monospace";
                ctx.textBaseline = "middle";
                for (const node of data.nodes) {
                    const x = padL + node.x * drawW;
                    const w = node.w * drawW;
                    const y = baseY - (node.depth + 1) * FG_ROW_H;
                    if (w < 0.5) continue;
                    ctx.fillStyle = flamegraphColor(node.name);
                    ctx.fillRect(x, y, Math.max(w - 0.5, 0.5), FG_ROW_H - 1);
                    regions.push({ x1: x, x2: x + w, y, node, totalSamples: data.totalSamples });
                    if (w > 30) {
                        ctx.fillStyle = "#fff";
                        const label = node.name.length * 7 > w - 4
                            ? node.name.slice(0, Math.floor((w - 10) / 7)) + "â€¦"
                            : node.name;
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(x + 2, y, w - 4, FG_ROW_H);
                        ctx.clip();
                        ctx.fillText(label, x + 3, y + FG_ROW_H / 2);
                        ctx.restore();
                    }
                }
                fgHitRegions[hitKey] = regions;
            }

            function renderFlamegraph() {
                renderFgCanvas("fg-canvas-worker", fgWorkerData, "worker");
                renderFgCanvas("fg-canvas-offworker", fgOffworkerData, "offworker");
            }

            // Flamegraph tooltip â€” shared handler for both canvases
            function fgCanvasMouseMove(e, hitKey) {
                const c = e.target;
                const rect = c.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                const tip = document.getElementById("fg-tooltip");
                const regions = fgHitRegions[hitKey] || [];
                let hit = null;
                for (let i = regions.length - 1; i >= 0; i--) {
                    const r = regions[i];
                    if (mx >= r.x1 && mx <= r.x2 && my >= r.y && my < r.y + FG_ROW_H) {
                        hit = r;
                        break;
                    }
                }
                if (hit) {
                    const total = hit.totalSamples;
                    const pct = ((hit.node.count / total) * 100).toFixed(1);
                    const selfPct = ((hit.node.self / total) * 100).toFixed(1);
                    tip.innerHTML = `<b>${hit.node.name}</b><br>${hit.node.count} samples (${pct}%) Â· ${hit.node.self} self (${selfPct}%)`;
                    tip.style.display = "block";
                    tip.style.left = Math.min(e.clientX + 12, window.innerWidth - 620) + "px";
                    tip.style.top = (e.clientY - 50) + "px";
                    c.style.cursor = "pointer";
                } else {
                    tip.style.display = "none";
                    c.style.cursor = "";
                }
            }

            document.getElementById("fg-canvas-worker").addEventListener("mousemove", (e) => fgCanvasMouseMove(e, "worker"));
            document.getElementById("fg-canvas-offworker").addEventListener("mousemove", (e) => fgCanvasMouseMove(e, "offworker"));
            document.getElementById("fg-canvas-worker").addEventListener("mouseleave", () => {
                document.getElementById("fg-tooltip").style.display = "none";
            });
            document.getElementById("fg-canvas-offworker").addEventListener("mouseleave", () => {
                document.getElementById("fg-tooltip").style.display = "none";
            });

            document.getElementById("fg-close").addEventListener("click", () => {
                document.getElementById("flamegraph-panel").style.display = "none";
                document.getElementById("fg-tooltip").style.display = "none";
            });

            // Re-render flamegraph on resize
            window.addEventListener("resize", () => {
                if (document.getElementById("flamegraph-panel").style.display === "flex") {
                    renderFlamegraph();
                }
            });
        </script>
    </body>
</html>
